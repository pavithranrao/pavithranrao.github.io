{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>Hi \u270b! I am Pavi (short for Pavithran). I am a Software Engineer mostly experienced in ML and Data Infrastructure. This is my digital garden inspired by Lyz's The Blue Book.</p>"},{"location":"about/about/","title":"About","text":""},{"location":"about/about/#links","title":"Links","text":"<ul> <li>Github</li> <li>StackOverFlow</li> <li>LinkedIn</li> </ul>"},{"location":"about/about/#contact","title":"Contact","text":"<ul> <li>Mail: <code>pavithran38[at]pec[dot]edu</code></li> </ul>"},{"location":"c%2B%2B/c%2B%2B_for_python/","title":"C++ for python","text":"<p>After working a long time in Python, I tend to forget the basic C++ syntax. The document compares the syntax between Python and C++ and can refresh the C++ syntax with little effort.</p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#primitive-types","title":"Primitive Types","text":"<pre><code>x: int = 10\nx: float = 10.1\nx: char = 'a' \nx: str = \"abc\"\nx: bool = True\nx: None = None\n</code></pre> <pre><code>int x = 10;\nfloat x = 10.1;\nchar x = 'a';\nstring x = \"abc\"; // #include &lt;string.h&gt;\nbool x = true;\nstd::nullptr_t x = nullptr; // #include &lt;cstddef&gt;\n</code></pre>"},{"location":"c%2B%2B/c%2B%2B_for_python/#int","title":"Int","text":"<p>Python <pre><code># str to int\nnum = int(\"10\")  # 10\n\n# int to str\nnumber = str(42)    # \"42\" \n</code></pre></p> <p>C++ <pre><code>#include &lt;string&gt;\n\n// string to int\nint num = std::stoi(\"10\")      // 10\n\n// int to string\nstring number = std::to_string(42); // \"42\"\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#float","title":"Float","text":"<p>Python <pre><code># str to int\nnum = float(\"10.1\")  # 10.1\n\n# int to str\nnumber = str(42.24)    # \"42.24\" \n</code></pre></p> <p>C++ <pre><code>#include &lt;string&gt;\n\n// string to int\nint num = std::stof(\"10.1\")      // 10.1\ndouble num_double = std::stod(\"10.1\");\n\n// int to string\nstring number = std::to_string(42.24); // \"42.24\"\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#division-and-modulo","title":"Division and Modulo","text":"<p>Python <pre><code>quotient, reminder = divmod(10,3)\n\n# quotient = 3, reminder = 1\n</code></pre></p> <p>C++ <pre><code>auto [quotient, reminder] = std::div(10, 3);\n\n//  quotient = 3, reminder = 1\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#char","title":"Char","text":"<p>Python <pre><code># int to char\nasciiValue: int = 65;\ncharacter: str = chr(asciiValue);  # \"A\"\n\n# char to int (ascii ordinal)\na: str = 'a';\nint_a: int = ord(a);                # 97\n</code></pre></p> <p>C++ <pre><code>// int to char\nint asciiValue = 65;\nchar character = char(asciiValue);  // 'A'\n\n// char to int (ascii ordinal)\nchar a = 'a';\nint int_a = int(a);                // 97\nint int_a = (int) a;               // 97\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#string","title":"String","text":"<p>[!info] &gt; <code>str</code> in Python is immutable, whereas <code>string</code> in C++ is mutable</p> <p>Python</p> <pre><code>hello = \"Hello\"\nlength: int = len(hello) # 5\n\nchar_at_1: chr = hello[1] # 'e'\n\n# check equality\nhello == \"Hello\" # True\n\n# string concatenation\nhello + \", \" + \"World!\" # \"Hello, World!\"\n\n# emptyness check\n\"\" is None # True\n\n# str in list of chars\ndata = list(hello)     # ['H', 'e', 'l', 'l', 'o']\n</code></pre> <p>C++</p> <pre><code>#include &lt;string&gt;\n#include &lt;vector&gt;\n\nstd::string hello = \"Hello\";\nsize_t length = hello.length();  // 5\n// `hello.size()` also works\n\n// check equality\nhello == \"Hello\"; // true\n\n// string concatenation\nhello + \", \" + \"World!\" // \"Hello, World!\"\n\nchar char_at_1 = hello[2]; // 'e'\n\n// emptyness check\nstd::string emptyString = \"\";\nemptyString.empty() // true\n\nstd::vector&lt;char&gt; data(str.begin(), str.end());\n\n// eq\n// std::copy(str.begin(), str.end(), std::back_inserter(data));\n</code></pre>"},{"location":"c%2B%2B/c%2B%2B_for_python/#bool","title":"Bool","text":"<p>Python</p> <pre><code>a: = True\nb: = False\n\na and b # False\na or b  # True\nnot a   # False\n</code></pre> <p>C++</p> <pre><code>bool a = true;\nbool b = false;\n\na and b; // false\na or b;  // true\nnot a;   // false\n</code></pre> <p>In <code>Python</code> Source: https://docs.python.org/3/library/stdtypes.html#boolean-operations-and-or-not</p> Operation Result Notes <code>x\u00a0or\u00a0y</code> if\u00a0x\u00a0is true, then\u00a0x, else\u00a0y (1) <code>x\u00a0and\u00a0y</code> if\u00a0x\u00a0is false, then\u00a0x, else\u00a0y (2) <code>not\u00a0x</code> if\u00a0x\u00a0is false, then\u00a0<code>True</code>, else\u00a0<code>False</code> (3) Notes: 1. This is a short-circuit operator, so it only evaluates the second argument if the first one is false. 2. This is a short-circuit operator, so it only evaluates the second argument if the first one is true. 3. <code>not</code>\u00a0has a lower priority than non-Boolean operators, so\u00a0<code>not\u00a0a\u00a0==\u00a0b</code>\u00a0is interpreted as\u00a0<code>not\u00a0(a\u00a0==\u00a0b)</code>, and\u00a0<code>a\u00a0==\u00a0not\u00a0b</code>\u00a0is a syntax error. <p>In <code>C++</code></p> <p>Source: https://en.cppreference.com/w/cpp/language/operator_logical</p> Operator name Syntax Over\u200bload\u200bable Prototype examples (for\u00a0class\u00a0T) Inside class definition Outside class definition negation not a!a Yes bool\u00a0T::operator!()\u00a0const; bool\u00a0operator!(const\u00a0T\u00a0&amp;a); AND a and ba\u00a0&amp;&amp;\u00a0b Yes bool\u00a0T::operator&amp;&amp;(const\u00a0T2\u00a0&amp;b)\u00a0const; bool\u00a0operator&amp;&amp;(const\u00a0T\u00a0&amp;a,\u00a0const\u00a0T2\u00a0&amp;b); inclusive OR a or ba\u00a0|\u00a0b Yes bool\u00a0T::operator|(const\u00a0T2\u00a0&amp;b)\u00a0const; bool\u00a0operator|(const\u00a0T\u00a0&amp;a,\u00a0const\u00a0T2\u00a0&amp;b); <p>Notes </p> <ul> <li>The keyword-like forms (and,or,not) and the symbol-like forms (&amp;&amp;,|,!) can be used interchangeably (see\u00a0alternative representations).</li> <li>All built-in operators return\u00a0bool, and most\u00a0user-defined overloads\u00a0also return\u00a0bool\u00a0so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including\u00a0void).</li> <li>Built-in operators\u00a0<code>**&amp;&amp;**</code>\u00a0and\u00a0<code>**|**</code>\u00a0perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands.</li> </ul>"},{"location":"c%2B%2B/c%2B%2B_for_python/#none-vs-nullptr","title":"None vs <code>nullptr</code>","text":"<p>Python's <code>None</code> is similar to C++ <code>nullptr</code>. C++ <code>nullptr</code> is also used to find end of an iterator whereas in Python the iterator terminates with an Exception.</p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#lists-iterators","title":"Lists, Iterators","text":"<p>Python</p> <pre><code>a = [1, 2, 3]\nreverse(a)  # [3, 2, 1]\nlen(a)      # 3\n\na.append(4)\nfor x in a:\n    print(a)\n\nlist_of_3_same_value_100 = [100] * 3\n\na = [1, 2, 4, 5]\na.insert(2, 3) # (index, value) # [1, 2, 3, 4, 5]\n\n\n# look at last element\na[-1]  # 5\na.pop() # 5 and `a` becomes [1, 2, 3, 4]\n</code></pre> <p>C++ <pre><code>#include &lt;vector&gt;\n#include &lt;algorithm&gt;  # std::reverse\n\nstd::vector&lt;int&gt; a = {1, 2, 3};\n\n// inplace reverse\nstd::reverse(a.begin(), a.end()); // {3, 2, 1}\n\na.push_back(4);\n\nfor (auto x: a) {\n    std::cout &lt;&lt; x &lt;&lt; std::endl;\n}\n\nstd::vector&lt;int&gt; list_of_3_same_value_100 (/*size=*/3, /*value=*/100);\n\nstd::vector&lt;int&gt; a = {1, 2, 4, 5}; \na.insert(a.begin() + 2, 3);  // {1, 2, 3, 4, 5}\n// insert from the end will also work\n// a.insert(a.end() - 1, 10);\n\n// look at last element\na.back()  // 5\na.pop_back()   // doesn't return 5 and `a` becomes [1, 2, 3, 4]\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#hashmap","title":"HashMap","text":"<p>Python <pre><code>from collections import defaultdict\n\nmap = defaultdict(int)\nmap[1] = 1\nmap[2] = 3\n\nfor i in range(4):\n    print(f\"map[{i}] -&gt; {map[i]}\")\n\n# map[0] -&gt; 0\n# map[1] -&gt; 1\n# map[2] -&gt; 3\n# map[3] -&gt; 0\n</code></pre></p> <p>C++</p> <pre><code>unordered_map&lt;int, size_t&gt; map = {{1, 1}, {2, 3}};\n\nfor (int i = 1; i &lt; 4; i++) {\n    auto emplace_pair = map.emplace(i, 0);\n    std::cout &lt;&lt; \"map[\" &lt;&lt; i &lt;&lt; \"] -&gt; \" &lt;&lt; map[i] &lt;&lt; std::endl;  \n}\n\n// map[0] -&gt; 0\n// map[1] -&gt; 1\n// map[2] -&gt; 3\n// map[3] -&gt; 0\n</code></pre>"},{"location":"c%2B%2B/c%2B%2B_for_python/#swap","title":"Swap","text":"<p>The swap in Python is just amazing. Why can't all the other languages copy this! In C++'s defense <code>std::swap</code> is not that bad;</p> <p>Python <pre><code>x = 10\ny = 5\nprint(\"Before swap:\")\nprint(f\"{x=} {y=}\")\nprint(\"After swap:\")\nprint(f\"{x=} {y=}\")\n\n# Before swap:\n# x=10 y=5\n\n# After swap:\n# x=5 y=10\n\n# just a python thing\na, b, c, d = 1, 2, 3, 4\na, b, c, d = d, c, b, a\n\nprint(f\"{a=} {b=} {c=} {d=}\")\n\n# a=4 b=3 c=2 d=1\n</code></pre></p> <p>C++</p> <pre><code>int x = 10;\nint y = 5;\n\nstd::cout &lt;&lt; \"Before swap:\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl;\nstd::swap(x, y);\n\nstd::cout &lt;&lt; \"After swap:\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; std::endl;\n\n// Before swap:\n// x: 10 y: 5\n\n// After swap:\n// x: 5 y: 10\n</code></pre>"},{"location":"c%2B%2B/c%2B%2B_for_python/#class-and-structs","title":"Class and structs","text":"<p>C++ <code>struct</code>s are equivalent to <code>namedtuple</code> in Python but more powerful that the <code>namedtuple</code>. The C++ <code>struct</code> can have functions, constructors and destructors.</p> <p>Python</p> <pre><code># Basic example\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(11, y=22)     # instantiate with positional or keyword arguments\np[0] + p[1]             # indexable like the plain tuple (11, 22)\nx, y = p                # unpack like a regular tuple\nx, y\n\np.x + p.y               # fields also accessible by name\np                       # readable __repr__ with a name=value style\n</code></pre> <p>C++</p> <pre><code>#include &lt;iostream&gt;\n\nstruct coordinate {\n    int x = 5;\n    int y;\n\n    coordinate(int _y): x(10) { // constructors\n        y = _y;\n    }\n\n    coordinate(int _x, int _y) {\n        x = _x;\n        y = _y;\n    }\n\n    coordinate() {\n        y = 20;\n    }\n    ~coordinate() {} // destructor\n\n    void print() {\n        std::cout &lt;&lt; \"(\" &lt;&lt;  x &lt;&lt; \" , \" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; std::endl;\n    }\n};\n\n\n// Write C++ code here\ncoordinate c1;\n// coordinate()\nc1.print();\nc1.x = 100;\nc1.y = 200;\nc1.print();\n\ncoordinate c2(20);\n// coordinate(int _y): x(10)\nc2.print();\n\ncoordinate c3 = {-1, -1};\n// coordinate(int _x, int _y)\nc3.print();\n</code></pre>"},{"location":"c%2B%2B/c%2B%2B_for_python/#tuple","title":"Tuple","text":"<p>Similar to Python's <code>tuple</code> type, C++ has <code>std::tuple</code> from <code>tuple</code> header and <code>pair</code> a special case of <code>tuple</code> with two elements to offer. This comes handy when a function has to return more than one value. Things of similar context can be grouped into a <code>tuple</code> or <code>pair</code>.</p> <p>The key difference is <code>tuple</code> in Python is immutable whereas in C++ <code>std::tuple</code> and <code>std::pair</code> are mutable containers.</p> <p>Python <pre><code>point = (1, 1)\npoint[0], point[1] # 1, 1\n\nstudent = (\"John Doe\", 1, 2.3)\n# syntatic destructure\nname, age, score = student\n</code></pre></p> <p>C++ <pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;utility&gt;\n#include &lt;string&gt;\n\nstd::pair&lt;int, int&gt; point = {1, 1};\nstd::cout &lt;&lt; point.first &lt;&lt; \" \" &lt;&lt; point.second &lt;&lt; std::endl; // 1 1\n\n\nstd::tuple&lt;std::string, int, float&gt; student = {\"John Doe\", 1, 1.2};\n\n# syntatic destructure\nconst auto&amp; [name, age, score] = student;\nstd::cout \n    &lt;&lt; \"Name: \" &lt;&lt; name\n    &lt;&lt; \" Age: \" &lt;&lt; age\n    &lt;&lt; \" Score: \" &lt;&lt; score\n    &lt;&lt; std::endl;\n// Name: John Doe Age: 1 Score: 1.2\n</code></pre></p>"},{"location":"c%2B%2B/c%2B%2B_for_python/#foot-note","title":"Foot Note","text":"<ol> <li>Runestone academy's C++ for Python Programmers is great place to start. </li> </ol>"},{"location":"python/python/","title":"Introduction","text":"<p>My exploration of few python packages are documented here.</p>"},{"location":"python/pattern_matching/pattern_matching/","title":"Pattern Matching in Python","text":"<p>PEP-0636</p>"},{"location":"python/pattern_matching/pattern_matching/#matching-a-python-builtin-type","title":"Matching a python builtin type","text":"<pre><code>def fib(n: int):\n    match n:\n        case 0:\n            return 0\n        case 1:\n            return 1\n        case n:\n            return fib(n - 1) + fib(n - 2)\n\nfib(10)\n</code></pre> <pre><code>55\n</code></pre>"},{"location":"python/pattern_matching/pattern_matching/#matching-a-python-list","title":"Matching a python list","text":"<pre><code>def sum_list(xs: list[int]) -&gt; int:\n    match xs:\n        case [x]:\n            return x\n        case [x, *ys]:\n            return x + sum_list(ys)\n\nassert(\n    sum_list(list(range(10))) == sum(range(10))\n)\n</code></pre>"},{"location":"python/pattern_matching/pattern_matching/#matching-python-enums","title":"Matching Python enums","text":"<pre><code>from datetime import date\nimport enum\nclass Weekday(enum.Enum):\n    MONDAY = 1\n    TUESDAY = 2\n    WEDNESDAY = 3\n    THURSDAY = 4\n    FRIDAY = 5\n    SATURDAY = 6\n    SUNDAY = 7\n\n\n\ndef is_day_a_weekend(day: Weekday):\n    match day:\n        case Weekday.SATURDAY | Weekday.SUNDAY:\n            print(f\"Yippee it's {day.name}!\")\n        case _:\n            print(f\"We are {6 - day.value} day(s) away from Saturday\")\n\nis_day_a_weekend(Weekday.FRIDAY)\nis_day_a_weekend(Weekday.SATURDAY)\n</code></pre> <pre><code>We are 1 day(s) away from Saturday\nYippee it's SATURDAY!\n</code></pre>"},{"location":"python/pattern_matching/pattern_matching/#matching-with-multiple-predicates-and-wildcards","title":"Matching with multiple predicates and wildcards","text":"<p>Fizz-Buzz program</p> <pre><code>def fizz_buzz(n: int) -&gt; str:\n    \"\"\"\n    num == \"FizzBuzz\" if num is divisible by 3 and 5.\n    num == \"Fizz\" if num is divisible by 3.\n    num == \"Buzz\" if num is divisible by 5.\n    num == num (as a string) if none of the above conditions are true.\n\n    Args:\n        n (int): A positive integer.\n\n    Returns:\n        str: FizzBUzz string for the num.\n    \"\"\"\n    match (n % 3, n % 5):\n        case (0, 0):\n            return \"FizzBuzz\"\n        case (0, _):\n            return \"Fizz\"\n        case (_, 0):\n            return \"Buzz\"\n        case _:\n            return str(n)\n\nfor num in range(10, 16):\n    print(f\"{num=} {fizz_buzz(num)}\")\n</code></pre> <pre><code>num=10 Buzz\nnum=11 11\nnum=12 Fizz\nnum=13 13\nnum=14 14\nnum=15 FizzBuzz\n</code></pre> <pre><code>from collections import namedtuple\nPoint = namedtuple(\"Point\", \"x y\")\npoint = Point(2, 4)\n\nmatch point:\n    case Point(x=a, y=b):\n        print(a, b)\n    case _:\n        print(\"nope!\")\n</code></pre> <pre><code>2 4\n</code></pre> <pre><code>data = {\"b\": 20, \"a\": 10}\nmatch data:\n    case {\"a\": a, **others}:\n        print(a)\n    case {\"b\": b, **others}:\n        print(b)\n    case _:\n        print(data)\n</code></pre> <pre><code>10\n</code></pre> <pre><code>import requests\n\nresponse = requests.get(\"https://pavithranrao.github.io\")\nmatch response.status_code:\n    case 200:\n        print(len(response.content))\n    case x if x &gt;= 400:\n        print(f\"HTTPError: {response.reason}\")\n    case _:\n        print(response)\n</code></pre> <pre><code>18586\n</code></pre>"},{"location":"python/pattern_matching/pattern_matching/#matching-a-python-class-or-dataclass","title":"Matching a Python class or dataclass","text":"<pre><code>import dataclasses\n\n@dataclasses.dataclass\nclass Command:\n    command_type: str\n    command_args: list[str]\n\ndef perform_fn(command: Command):\n    match command:\n        case Command(command_type, command_args) if command_type == \"echo\":\n            print(command_args[0])\n        case _:\n            print(\"unimplemented command!\")\n\necho = Command(\n    command_type=\"echo\",\n    command_args=[\"Hello, World!\"]\n)\nperform_fn(echo)\n</code></pre> <pre><code>Hello, World!\n</code></pre>"},{"location":"python/pattern_matching/pattern_matching/#end-note","title":"End Note","text":"<p>I also found these blogs useful:</p> <ul> <li>Ben Hoyt's Structural pattern matching in Python 3.10</li> <li>Inspired Python's Mastering Structural Pattern Matching</li> </ul>"},{"location":"rust/intro/intro/","title":"Introduction","text":"<p>My learnings and scribblings in Rust</p>"},{"location":"rust/rustlings/00.intro/","title":"00.intro","text":""},{"location":"rust/rustlings/00.intro/#intro1rs","title":"intro1.rs","text":"<p>Github solution link <pre><code>// intro1.rs\n//\n// About this `I AM NOT DONE` thing:\n// We sometimes encourage you to keep trying things on a given exercise, even\n// after you already figured it out. If you got everything working and feel\n// ready for the next exercise, remove the `I AM NOT DONE` comment below.\n//\n// If you're running this using `rustlings watch`: The exercise file will be\n// reloaded when you change one of the lines below! Try adding a `println!`\n// line, or try changing what it outputs in your terminal. Try removing a\n// semicolon and see what happens!\n//\n// Execute `rustlings hint intro1` or use the `hint` watch subcommand for a\n// hint.\n\nfn main() {\n    println!(\"Hello and\");\n    println!(r#\"       welcome to...                      \"#);\n    println!(r#\"                 _   _ _                  \"#);\n    println!(r#\"  _ __ _   _ ___| |_| (_)_ __   __ _ ___  \"#);\n    println!(r#\" | '__| | | / __| __| | | '_ \\ / _` / __| \"#);\n    println!(r#\" | |  | |_| \\__ \\ |_| | | | | | (_| \\__ \\ \"#);\n    println!(r#\" |_|   \\__,_|___/\\__|_|_|_| |_|\\__, |___/ \"#);\n    println!(r#\"                               |___/      \"#);\n    println!();\n    println!(\"This exercise compiles successfully. The remaining exercises contain a compiler\");\n    println!(\"or logic error. The central concept behind Rustlings is to fix these errors and\");\n    println!(\"solve the exercises. Good luck!\");\n    println!();\n    println!(\"The source for this exercise is in `exercises/00_intro/intro1.rs`. Have a look!\");\n    println!(\n        \"Going forward, the source of the exercises will always be in the success/failure output.\"\n    );\n    println!();\n    println!(\n        \"If you want to use rust-analyzer, Rust's LSP implementation, make sure your editor is set\"\n    );\n    println!(\"up, and then run `rustlings lsp` before continuing.\")\n}\n</code></pre></p>"},{"location":"rust/rustlings/00.intro/#intro2rs","title":"intro2.rs","text":"<p>Github solution link <pre><code>// intro2.rs\n//\n// Make the code print a greeting to the world.\n//\n// Execute `rustlings hint intro2` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let world = \"world\";\n    println!(\"Hello {}!\", world);\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/","title":"01.variables","text":""},{"location":"rust/rustlings/01.variables/#variables1rs","title":"variables1.rs","text":"<p>Github solution link <pre><code>// variables1.rs\n//\n// Make me compile!\n//\n// Execute `rustlings hint variables1` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let x = 5;\n    println!(\"x has the value {}\", x);\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/#variables2rs","title":"variables2.rs","text":"<p>Github solution link <pre><code>// variables2.rs\n//\n// Execute `rustlings hint variables2` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let x : i32 = 10;\n    if x == 10 {\n        println!(\"x is ten!\");\n    } else {\n        println!(\"x is not ten!\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/#variables3rs","title":"variables3.rs","text":"<p>Github solution link <pre><code>// variables3.rs\n//\n// Execute `rustlings hint variables3` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let x: i32 = 42;\n    println!(\"Number {}\", x);\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/#variables4rs","title":"variables4.rs","text":"<p>Github solution link <pre><code>// variables4.rs\n//\n// Execute `rustlings hint variables4` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let mut x = 3;\n    println!(\"Number {}\", x);\n    x = 5; // don't change this line\n    println!(\"Number {}\", x);\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/#variables5rs","title":"variables5.rs","text":"<p>Github solution link <pre><code>// variables5.rs\n//\n// Execute `rustlings hint variables5` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let number = \"T-H-R-E-E\"; // don't change this line\n    println!(\"Spell a Number : {}\", number);\n    let number = 3; // don't rename this variable\n    println!(\"Number plus two is : {}\", number + 2);\n}\n</code></pre></p>"},{"location":"rust/rustlings/01.variables/#variables6rs","title":"variables6.rs","text":"<p>Github solution link <pre><code>// variables6.rs\n//\n// Execute `rustlings hint variables6` or use the `hint` watch subcommand for a\n// hint.\n\n\nconst NUMBER: i32 = 3;\nfn main() {\n    println!(\"Number {}\", NUMBER);\n}\n</code></pre></p>"},{"location":"rust/rustlings/02.functions/","title":"02.functions","text":""},{"location":"rust/rustlings/02.functions/#functions1rs","title":"functions1.rs","text":"<p>Github solution link <pre><code>// functions1.rs\n//\n// Execute `rustlings hint functions1` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn call_me() {\n    println!(\"Hello, world!\");\n}\n\nfn main() {\n    call_me();\n}\n</code></pre></p>"},{"location":"rust/rustlings/02.functions/#functions2rs","title":"functions2.rs","text":"<p>Github solution link <pre><code>// functions2.rs\n//\n// Execute `rustlings hint functions2` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num: i32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/02.functions/#functions3rs","title":"functions3.rs","text":"<p>Github solution link <pre><code>// functions3.rs\n//\n// Execute `rustlings hint functions3` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    call_me(/*num=*/5);\n}\n\nfn call_me(num: u32) {\n    for i in 0..num {\n        println!(\"Ring! Call number {}\", i + 1);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/02.functions/#functions4rs","title":"functions4.rs","text":"<p>Github solution link <pre><code>// functions4.rs\n//\n// This store is having a sale where if the price is an even number, you get 10\n// Rustbucks off, but if it's an odd number, it's 3 Rustbucks off. (Don't worry\n// about the function bodies themselves, we're only interested in the signatures\n// for now. If anything, this is a good way to peek ahead to future exercises!)\n//\n// Execute `rustlings hint functions4` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let original_price = 51;\n    println!(\"Your sale price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: i32) -&gt; f32 {\n    if is_even(price) {\n        ((price - 10) as f32) * 0.1\n    } else {\n        (price - 3) as f32\n    }\n}\n\nfn is_even(num: i32) -&gt; bool {\n    num % 2 == 0\n}\n</code></pre></p>"},{"location":"rust/rustlings/02.functions/#functions5rs","title":"functions5.rs","text":"<p>Github solution link <pre><code>// functions5.rs\n//\n// Execute `rustlings hint functions5` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let answer = square(3);\n    println!(\"The square of 3 is {}\", answer);\n}\n\nfn square(num: i32) -&gt; i32 {\n    num * num\n}\n</code></pre></p>"},{"location":"rust/rustlings/03.if/","title":"03.if","text":""},{"location":"rust/rustlings/03.if/#if1rs","title":"if1.rs","text":"<p>Github solution link <pre><code>// if1.rs\n//\n// Execute `rustlings hint if1` or use the `hint` watch subcommand for a hint.\n\n\npub fn bigger(a: i32, b: i32) -&gt; i32 {\n    // Complete this function to return the bigger number!\n    // Do not use:\n    // - another function call\n    // - additional variables\n    if a &gt; b {\n        a\n    } else {\n        b\n    }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert_eq!(10, bigger(10, 8));\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert_eq!(42, bigger(32, 42));\n    }\n\n    #[test]\n    fn equal_numbers() {\n        assert_eq!(42, bigger(42, 42));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/03.if/#if2rs","title":"if2.rs","text":"<p>Github solution link <pre><code>// if2.rs\n//\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n//\n// Execute `rustlings hint if2` or use the `hint` watch subcommand for a hint.\n\n\npub fn foo_if_fizz(fizzish: &amp;str) -&gt; &amp;str {\n    // if fizzish == \"fizz\" {\n    //     \"foo\"\n    // } else if fizzish == \"fuzz\" {\n    //     \"bar\"\n    // } else {\n    //     \"baz\"\n    // }\n    match fizzish {\n        \"fizz\" =&gt; {\"foo\"}\n        \"fuzz\" =&gt; {\"bar\"}\n        _ =&gt; {\"baz\"}\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert_eq!(foo_if_fizz(\"fizz\"), \"foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert_eq!(foo_if_fizz(\"fuzz\"), \"bar\")\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert_eq!(foo_if_fizz(\"literally anything\"), \"baz\")\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/03.if/#if3rs","title":"if3.rs","text":"<p>Github solution link <pre><code>// if3.rs\n//\n// Execute `rustlings hint if3` or use the `hint` watch subcommand for a hint.\n\n\npub fn animal_habitat(animal: &amp;str) -&gt; &amp;'static str {\n    let identifier = if animal == \"crab\" {\n        1\n    } else if animal == \"gopher\" {\n        2\n    } else if animal == \"snake\" {\n        3\n    } else {\n        0\n    };\n\n    // DO NOT CHANGE THIS STATEMENT BELOW\n    let habitat = if identifier == 1 {\n        \"Beach\"\n    } else if identifier == 2 {\n        \"Burrow\"\n    } else if identifier == 3 {\n        \"Desert\"\n    } else {\n        \"Unknown\"\n    };\n\n    habitat\n}\n\n// No test changes needed.\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn gopher_lives_in_burrow() {\n        assert_eq!(animal_habitat(\"gopher\"), \"Burrow\")\n    }\n\n    #[test]\n    fn snake_lives_in_desert() {\n        assert_eq!(animal_habitat(\"snake\"), \"Desert\")\n    }\n\n    #[test]\n    fn crab_lives_on_beach() {\n        assert_eq!(animal_habitat(\"crab\"), \"Beach\")\n    }\n\n    #[test]\n    fn unknown_animal() {\n        assert_eq!(animal_habitat(\"dinosaur\"), \"Unknown\")\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/","title":"04.primitive types","text":""},{"location":"rust/rustlings/04.primitive_types/#primitive_types1rs","title":"primitive_types1.rs","text":"<p>Github solution link <pre><code>// primitive_types1.rs\n//\n// Fill in the rest of the line that has code missing! No hints, there's no\n// tricks, just get used to typing these :)\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening = ! is_morning;// Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/#primitive_types2rs","title":"primitive_types2.rs","text":"<p>Github solution link <pre><code>// primitive_types2.rs\n//\n// Fill in the rest of the line that has code missing! No hints, there's no\n// tricks, just get used to typing these :)\n\n\nfn main() {\n    // Characters (`char`)\n\n    // Note the _single_ quotes, these are different from the double quotes\n    // you've been seeing around.\n    let my_first_initial = 'C';\n    if my_first_initial.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if my_first_initial.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n\n    let your_character = '\ud83e\udd80'; // Finish this line like the example! What's your favorite character?\n    // Try a letter, try a number, try a special character, try a character\n    // from a different language than your own, try an emoji!\n    if your_character.is_alphabetic() {\n        println!(\"Alphabetical!\");\n    } else if your_character.is_numeric() {\n        println!(\"Numerical!\");\n    } else {\n        println!(\"Neither alphabetic nor numeric!\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/#primitive_types3rs","title":"primitive_types3.rs","text":"<p>Github solution link <pre><code>// primitive_types3.rs\n//\n// Create an array with at least 100 elements in it where the ??? is.\n//\n// Execute `rustlings hint primitive_types3` or use the `hint` watch subcommand\n// for a hint.\n\n\nfn main() {\n    // let a = [\"Are we there yet?\"; 100];\n    let a = 1..101;\n\n    if a.len() &gt;= 100 {\n        println!(\"Wow, that's a big array!\");\n    } else {\n        println!(\"Meh, I eat arrays like that for breakfast.\");\n        panic!(\"Array not big enough, more elements needed\")\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/#primitive_types4rs","title":"primitive_types4.rs","text":"<p>Github solution link <pre><code>// primitive_types4.rs\n//\n// Get a slice out of Array a where the ??? is so that the test passes.\n//\n// Execute `rustlings hint primitive_types4` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn slice_out_of_array() {\n    let a = [1, 2, 3, 4, 5];\n\n    let nice_slice = &amp;a[1..4];\n\n    assert_eq!([2, 3, 4], nice_slice)\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/#primitive_types5rs","title":"primitive_types5.rs","text":"<p>Github solution link <pre><code>// primitive_types5.rs\n//\n// Destructure the `cat` tuple so that the println will work.\n//\n// Execute `rustlings hint primitive_types5` or use the `hint` watch subcommand\n// for a hint.\n\n\nfn main() {\n    let cat: (&amp;str, f32) = (\"Furry McFurson\", 3.5);\n    let (name, age) : (&amp;str, f32) = cat;\n\n    println!(\"{} is {} years old.\", name, age);\n}\n</code></pre></p>"},{"location":"rust/rustlings/04.primitive_types/#primitive_types6rs","title":"primitive_types6.rs","text":"<p>Github solution link <pre><code>// primitive_types6.rs\n//\n// Use a tuple index to access the second element of `numbers`. You can put the\n// expression for the second element where ??? is so that the test passes.\n//\n// Execute `rustlings hint primitive_types6` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn indexing_tuple() {\n    let numbers = (1, 2, 3);\n    // Replace below ??? with the tuple indexing syntax.\n    let second = numbers.1;\n\n    assert_eq!(2, second,\n        \"This is not the 2nd number in the tuple!\")\n}\n</code></pre></p>"},{"location":"rust/rustlings/05.vecs/","title":"05.vecs","text":""},{"location":"rust/rustlings/05.vecs/#vecs1rs","title":"vecs1.rs","text":"<p>Github solution link <pre><code>// vecs1.rs\n//\n// Your task is to create a `Vec` which holds the exact same elements as in the\n// array `a`.\n//\n// Make me compile and pass the test!\n//\n// Execute `rustlings hint vecs1` or use the `hint` watch subcommand for a hint.\n\n\nfn array_and_vec() -&gt; ([i32; 4], Vec&lt;i32&gt;) {\n    let a = [10, 20, 30, 40]; // a plain array\n    let v = vec![10, 20, 30, 40]; // TODO: declare your vector here with the macro for vectors\n\n    (a, v)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_array_and_vec_similarity() {\n        let (a, v) = array_and_vec();\n        assert_eq!(a, v[..]);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/05.vecs/#vecs2rs","title":"vecs2.rs","text":"<p>Github solution link <pre><code>// vecs2.rs\n//\n// A Vec of even numbers is given. Your task is to complete the loop so that\n// each number in the Vec is multiplied by 2.\n//\n// Make me pass the test!\n//\n// Execute `rustlings hint vecs2` or use the `hint` watch subcommand for a hint.\n\nfn vec_loop(mut v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    for element in v.iter_mut() {\n        // TODO: Fill this up so that each element in the Vec `v` is\n        // multiplied by 2.\n        *element *= 2\n    }\n\n    // At this point, `v` should be equal to [4, 8, 12, 16, 20].\n    v\n}\n\nfn vec_map(v: &amp;Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    v.iter().map(|element| {\n        // TODO: Do the same thing as above - but instead of mutating the\n        // Vec, you can just return the new number!\n        element * 2\n    }).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_vec_loop() {\n        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_loop(v.clone());\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());\n    }\n\n    #[test]\n    fn test_vec_map() {\n        let v: Vec&lt;i32&gt; = (1..).filter(|x| x % 2 == 0).take(5).collect();\n        let ans = vec_map(&amp;v);\n\n        assert_eq!(ans, v.iter().map(|x| x * 2).collect::&lt;Vec&lt;i32&gt;&gt;());\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/","title":"06.move semantics","text":""},{"location":"rust/rustlings/06.move_semantics/#move_semantics1rs","title":"move_semantics1.rs","text":"<p>Github solution link <pre><code>// move_semantics1.rs\n//\n// Execute `rustlings hint move_semantics1` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn main() {\n    let vec0 = vec![22, 44, 66];\n\n    let vec1 = fill_vec(vec0);\n\n    assert_eq!(vec1, vec![22, 44, 66, 88]);\n}\n\nfn fill_vec(vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut vec = vec;\n\n    vec.push(88);\n\n    vec\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/#move_semantics2rs","title":"move_semantics2.rs","text":"<p>Github solution link <pre><code>// move_semantics2.rs\n//\n// Make the test pass by finding a way to keep both Vecs separate!\n//\n// Execute `rustlings hint move_semantics2` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn main() {\n    let vec0 = vec![22, 44, 66];\n\n    let vec1 = fill_vec(vec0.clone());\n\n    assert_eq!(vec0, vec![22, 44, 66]);\n    assert_eq!(vec1, vec![22, 44, 66, 88]);\n}\n\nfn fill_vec(mut vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    let mut vec = vec;\n\n    vec.push(88);\n\n    vec\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/#move_semantics3rs","title":"move_semantics3.rs","text":"<p>Github solution link <pre><code>// move_semantics3.rs\n//\n// Make me compile without adding new lines -- just changing existing lines! (no\n// lines with multiple semicolons necessary!)\n//\n// Execute `rustlings hint move_semantics3` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn main() {\n    let vec0 = vec![22, 44, 66];\n\n    let vec1 = fill_vec(vec0);\n\n    assert_eq!(vec1, vec![22, 44, 66, 88]);\n}\n\nfn fill_vec(mut vec: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {\n    vec.push(88);\n\n    vec\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/#move_semantics4rs","title":"move_semantics4.rs","text":"<p>Github solution link <pre><code>// move_semantics4.rs\n//\n// Refactor this code so that instead of passing `vec0` into the `fill_vec`\n// function, the Vector gets created in the function itself and passed back to\n// the main function.\n//\n// Execute `rustlings hint move_semantics4` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn main() {\n\n    let mut vec1 = fill_vec();\n\n    assert_eq!(vec1, vec![22, 44, 66, 88]);\n}\n\n// `fill_vec()` no longer takes `vec: Vec&lt;i32&gt;` as argument - don't change this!\nfn fill_vec() -&gt; Vec&lt;i32&gt; {\n    // Instead, let's create and fill the Vec in here - how do you do that?\n    let mut vec = vec![22, 44, 66];;\n\n    vec.push(88);\n\n    vec\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/#move_semantics5rs","title":"move_semantics5.rs","text":"<p>Github solution link <pre><code>// move_semantics5.rs\n//\n// Make me compile only by reordering the lines in `main()`, but without adding,\n// changing or removing any of them.\n//\n// Execute `rustlings hint move_semantics5` or use the `hint` watch subcommand\n// for a hint.\n\n\n#[test]\nfn main() {\n    let mut x = 100;\n    let y = &amp;mut x;\n    *y += 100;\n    let z = &amp;mut x;\n    *z += 1000;\n\n    assert_eq!(x, 1200);\n}\n</code></pre></p>"},{"location":"rust/rustlings/06.move_semantics/#move_semantics6rs","title":"move_semantics6.rs","text":"<p>Github solution link <pre><code>// move_semantics6.rs\n//\n// You can't change anything except adding or removing references.\n//\n// Execute `rustlings hint move_semantics6` or use the `hint` watch subcommand\n// for a hint.\n\n\nfn main() {\n    let data = \"Rust is great!\".to_string();\n\n    get_char(&amp;data);\n\n    string_uppercase(data);\n}\n\n// Should not take ownership\nfn get_char(data: &amp;String) -&gt; char {\n    data.chars().last().unwrap()\n}\n\n// Should take ownership\nfn string_uppercase(mut data: String) {\n    data = data.to_uppercase();\n\n    println!(\"{}\", data);\n}\n</code></pre></p>"},{"location":"rust/rustlings/07.structs/","title":"07.structs","text":""},{"location":"rust/rustlings/07.structs/#structs1rs","title":"structs1.rs","text":"<p>Github solution link <pre><code>// structs1.rs\n//\n// Address all the TODOs to make the tests pass!\n//\n// Execute `rustlings hint structs1` or use the `hint` watch subcommand for a\n// hint.\n\nstruct ColorClassicStruct {\n    // TODO: Something goes here\n    red: i32,\n    green: i32,\n    blue: i32,\n}\n\nstruct ColorTupleStruct(i32, i32, i32);\n\n#[derive(Debug)]\nstruct UnitLikeStruct;\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn classic_c_structs() {\n        // TODO: Instantiate a classic c struct!\n        let green = ColorClassicStruct {\n            red: 0,\n            green: 255,\n            blue: 0\n        };\n\n        assert_eq!(green.red, 0);\n        assert_eq!(green.green, 255);\n        assert_eq!(green.blue, 0);\n    }\n\n    #[test]\n    fn tuple_structs() {\n        // TODO: Instantiate a tuple struct!\n        let green = ColorTupleStruct(0, 255, 0);\n\n        assert_eq!(green.0, 0);\n        assert_eq!(green.1, 255);\n        assert_eq!(green.2, 0);\n    }\n\n    #[test]\n    fn unit_structs() {\n        // TODO: Instantiate a unit-like struct!\n        let unit_like_struct = UnitLikeStruct;\n        let message = format!(\"{:?}s are fun!\", unit_like_struct);\n\n        assert_eq!(message, \"UnitLikeStructs are fun!\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/07.structs/#structs2rs","title":"structs2.rs","text":"<p>Github solution link <pre><code>// structs2.rs\n//\n// Address all the TODOs to make the tests pass!\n//\n// Execute `rustlings hint structs2` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[derive(Debug)]\nstruct Order {\n    name: String,\n    year: u32,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: u32,\n    count: u32,\n}\n\nfn create_order_template() -&gt; Order {\n    Order {\n        name: String::from(\"Bob\"),\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn your_order() {\n        let order_template = create_order_template();\n        // TODO: Create your own order using the update syntax and template above!\n        let your_order = Order {\n            name: String::from(\"Hacker in Rust\"),\n            count: 1,\n            ..order_template\n        };\n        assert_eq!(your_order.name, \"Hacker in Rust\");\n        assert_eq!(your_order.year, order_template.year);\n        assert_eq!(your_order.made_by_phone, order_template.made_by_phone);\n        assert_eq!(your_order.made_by_mobile, order_template.made_by_mobile);\n        assert_eq!(your_order.made_by_email, order_template.made_by_email);\n        assert_eq!(your_order.item_number, order_template.item_number);\n        assert_eq!(your_order.count, 1);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/07.structs/#structs3rs","title":"structs3.rs","text":"<p>Github solution link <pre><code>// structs3.rs\n//\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n//\n// Execute `rustlings hint structs3` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[derive(Debug)]\nstruct Package {\n    sender_country: String,\n    recipient_country: String,\n    weight_in_grams: u32,\n}\n\nimpl Package {\n    fn new(sender_country: String, recipient_country: String, weight_in_grams: u32) -&gt; Package {\n        if weight_in_grams &lt; 10 {\n            // This is not how you should handle errors in Rust,\n            // but we will learn about error handling later.\n            panic!(\"Can not ship a package with weight below 10 grams.\")\n        } else {\n            Package {\n                sender_country,\n                recipient_country,\n                weight_in_grams,\n            }\n        }\n    }\n\n    fn is_international(&amp;self) -&gt; bool {\n        // Something goes here...\n        self.recipient_country != self.sender_country\n    }\n\n    fn get_fees(&amp;self, cents_per_gram: u32) -&gt; u32 {\n        // Something goes here...\n        self.weight_in_grams * cents_per_gram\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn fail_creating_weightless_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Austria\");\n\n        Package::new(sender_country, recipient_country, 5);\n    }\n\n    #[test]\n    fn create_international_package() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Russia\");\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(package.is_international());\n    }\n\n    #[test]\n    fn create_local_package() {\n        let sender_country = String::from(\"Canada\");\n        let recipient_country = sender_country.clone();\n\n        let package = Package::new(sender_country, recipient_country, 1200);\n\n        assert!(!package.is_international());\n    }\n\n    #[test]\n    fn calculate_transport_fees() {\n        let sender_country = String::from(\"Spain\");\n        let recipient_country = String::from(\"Spain\");\n\n        let cents_per_gram = 3;\n\n        let package = Package::new(sender_country, recipient_country, 1500);\n\n        assert_eq!(package.get_fees(cents_per_gram), 4500);\n        assert_eq!(package.get_fees(cents_per_gram * 2), 9000);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/08.enums/","title":"08.enums","text":""},{"location":"rust/rustlings/08.enums/#enums1rs","title":"enums1.rs","text":"<p>Github solution link <pre><code>// enums1.rs\n//\n// No hints this time! ;)\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define a few types of messages as used below\n    Quit,\n    Echo,\n    Move,\n    ChangeColor\n}\n\nfn main() {\n    println!(\"{:?}\", Message::Quit);\n    println!(\"{:?}\", Message::Echo);\n    println!(\"{:?}\", Message::Move);\n    println!(\"{:?}\", Message::ChangeColor);\n}\n</code></pre></p>"},{"location":"rust/rustlings/08.enums/#enums2rs","title":"enums2.rs","text":"<p>Github solution link <pre><code>// enums2.rs\n//\n// Execute `rustlings hint enums2` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[derive(Debug)]\nenum Message {\n    // TODO: define the different variants used below\n    Move { x: i32, y: i32},\n    Echo (String),\n    ChangeColor (i32, i32, i32),\n    Quit\n}\n\nimpl Message {\n    fn call(&amp;self) {\n        println!(\"{:?}\", self);\n    }\n}\n\nfn main() {\n    let messages = [\n        Message::Move { x: 10, y: 30 },\n        Message::Echo(String::from(\"hello world\")),\n        Message::ChangeColor(200, 255, 255),\n        Message::Quit,\n    ];\n\n    for message in &amp;messages {\n        message.call();\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/08.enums/#enums3rs","title":"enums3.rs","text":"<p>Github solution link <pre><code>// enums3.rs\n//\n// Address all the TODOs to make the tests pass!\n//\n// Execute `rustlings hint enums3` or use the `hint` watch subcommand for a\n// hint.\n\n\nenum Message {\n    // TODO: implement the message variant types based on their usage below\n    Move (Point),\n    Echo (String),\n    ChangeColor (u8, u8, u8),\n    Quit\n}\n\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n    message: String,\n}\n\nimpl State {\n    fn change_color(&amp;mut self, color: (u8, u8, u8)) {\n        self.color = color;\n    }\n\n    fn quit(&amp;mut self) {\n        self.quit = true;\n    }\n\n    fn echo(&amp;mut self, s: String) {\n        self.message = s\n    }\n\n    fn move_position(&amp;mut self, p: Point) {\n        self.position = p;\n    }\n\n    fn process(&amp;mut self, message: Message) {\n        // TODO: create a match expression to process the different message variants\n        // Remember: When passing a tuple as a function argument, you'll need extra parentheses:\n        // fn function((t, u, p, l, e))\n        match message {\n            Message::ChangeColor(r, g, b) =&gt; self.change_color((r, g, b)),\n            Message::Move(p) =&gt; self.move_position(p),\n            Message::Echo(s) =&gt; self.echo(s),\n            Message::Quit =&gt; self.quit()\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_match_message_call() {\n        let mut state = State {\n            quit: false,\n            position: Point { x: 0, y: 0 },\n            color: (0, 0, 0),\n            message: \"hello world\".to_string(),\n        };\n        state.process(Message::ChangeColor(255, 0, 255));\n        state.process(Message::Echo(String::from(\"Hello world!\")));\n        state.process(Message::Move(Point { x: 10, y: 15 }));\n        state.process(Message::Quit);\n\n        assert_eq!(state.color, (255, 0, 255));\n        assert_eq!(state.position.x, 10);\n        assert_eq!(state.position.y, 15);\n        assert_eq!(state.quit, true);\n        assert_eq!(state.message, \"Hello world!\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/09.strings/","title":"09.strings","text":""},{"location":"rust/rustlings/09.strings/#strings1rs","title":"strings1.rs","text":"<p>Github solution link <pre><code>// strings1.rs\n//\n// Make me compile without changing the function signature!\n//\n// Execute `rustlings hint strings1` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let answer = current_favorite_color();\n    println!(\"My current favorite color is {}\", answer);\n}\n\nfn current_favorite_color() -&gt; String {\n    String::from(\"blue\")\n}\n</code></pre></p>"},{"location":"rust/rustlings/09.strings/#strings2rs","title":"strings2.rs","text":"<p>Github solution link <pre><code>// strings2.rs\n//\n// Make me compile without changing the function signature!\n//\n// Execute `rustlings hint strings2` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let word = String::from(\"green\"); // Try not changing this line :)\n    if is_a_color_word(&amp;word) {\n        println!(\"That is a color word I know!\");\n    } else {\n        println!(\"That is not a color word I know.\");\n    }\n}\n\nfn is_a_color_word(attempt: &amp;str) -&gt; bool {\n    attempt == \"green\" || attempt == \"blue\" || attempt == \"red\"\n}\n</code></pre></p>"},{"location":"rust/rustlings/09.strings/#strings3rs","title":"strings3.rs","text":"<p>Github solution link <pre><code>// strings3.rs\n//\n// Execute `rustlings hint strings3` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn trim_me(input: &amp;str) -&gt; String {\n    // TODO: Remove whitespace from both ends of a string!\n    input.trim().to_string()\n}\n\nfn compose_me(input: &amp;str) -&gt; String {\n    // TODO: Add \" world!\" to the string! There's multiple ways to do this!\n    format!(\"{} world!\", input).to_string()\n}\n\nfn replace_me(input: &amp;str) -&gt; String {\n    // TODO: Replace \"cars\" in the string with \"balloons\"!\n    input.replace(\"cars\", \"balloons\")\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn trim_a_string() {\n        assert_eq!(trim_me(\"Hello!     \"), \"Hello!\");\n        assert_eq!(trim_me(\"  What's up!\"), \"What's up!\");\n        assert_eq!(trim_me(\"   Hola!  \"), \"Hola!\");\n    }\n\n    #[test]\n    fn compose_a_string() {\n        assert_eq!(compose_me(\"Hello\"), \"Hello world!\");\n        assert_eq!(compose_me(\"Goodbye\"), \"Goodbye world!\");\n    }\n\n    #[test]\n    fn replace_a_string() {\n        assert_eq!(replace_me(\"I think cars are cool\"), \"I think balloons are cool\");\n        assert_eq!(replace_me(\"I love to look at cars\"), \"I love to look at balloons\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/09.strings/#strings4rs","title":"strings4.rs","text":"<p>Github solution link <pre><code>// strings4.rs\n//\n// Ok, here are a bunch of values-- some are `String`s, some are `&amp;str`s. Your\n// task is to call one of these two functions on each value depending on what\n// you think each value is. That is, add either `string_slice` or `string`\n// before the parentheses on each line. If you're right, it will compile!\n//\n// No hints this time!\n\n\nfn string_slice(arg: &amp;str) {\n    println!(\"{}\", arg);\n}\nfn string(arg: String) {\n    println!(\"{}\", arg);\n}\n\nfn main() {\n    string_slice(\"blue\");\n    string(\"red\".to_string());\n    string(String::from(\"hi\"));\n    string(\"rust is fun!\".to_owned());\n    string_slice(\"nice weather\".into());\n    string(format!(\"Interpolation {}\", \"Station\"));\n    string_slice(&amp;String::from(\"abc\")[0..1]);\n    string_slice(\"  hello there \".trim());\n    string(\"Happy Monday!\".to_string().replace(\"Mon\", \"Tues\"));\n    string(\"mY sHiFt KeY iS sTiCkY\".to_lowercase());\n}\n</code></pre></p>"},{"location":"rust/rustlings/10.modules/","title":"10.modules","text":""},{"location":"rust/rustlings/10.modules/#modules1rs","title":"modules1.rs","text":"<p>Github solution link <pre><code>// modules1.rs\n//\n// Execute `rustlings hint modules1` or use the `hint` watch subcommand for a\n// hint.\n\n\nmod sausage_factory {\n    // Don't let anybody outside of this module see this!\n    fn get_secret_recipe() -&gt; String {\n        String::from(\"Ginger\")\n    }\n\n\n    pub fn make_sausage() {\n        get_secret_recipe();\n        println!(\"sausage!\");\n    }\n}\n\nfn main() {\n    sausage_factory::make_sausage();\n}\n</code></pre></p>"},{"location":"rust/rustlings/10.modules/#modules2rs","title":"modules2.rs","text":"<p>Github solution link <pre><code>// modules2.rs\n//\n// You can bring module paths into scopes and provide new names for them with\n// the 'use' and 'as' keywords. Fix these 'use' statements to make the code\n// compile.\n//\n// Execute `rustlings hint modules2` or use the `hint` watch subcommand for a\n// hint.\n\n\nmod delicious_snacks {\n    // TODO: Fix these use statements\n    pub use self::fruits::PEAR as fruit;\n    pub use self::veggies::CUCUMBER as veggie;\n\n    mod fruits {\n        pub const PEAR: &amp;'static str = \"Pear\";\n        pub const APPLE: &amp;'static str = \"Apple\";\n    }\n\n    mod veggies {\n        pub const CUCUMBER: &amp;'static str = \"Cucumber\";\n        pub const CARROT: &amp;'static str = \"Carrot\";\n    }\n}\n\nfn main() {\n    println!(\n        \"favorite snacks: {} and {}\",\n        delicious_snacks::fruit,\n        delicious_snacks::veggie\n    );\n}\n</code></pre></p>"},{"location":"rust/rustlings/10.modules/#modules3rs","title":"modules3.rs","text":"<p>Github solution link <pre><code>// modules3.rs\n//\n// You can use the 'use' keyword to bring module paths from modules from\n// anywhere and especially from the Rust standard library into your scope. Bring\n// SystemTime and UNIX_EPOCH from the std::time module. Bonus style points if\n// you can do it with one line!\n//\n// Execute `rustlings hint modules3` or use the `hint` watch subcommand for a\n// hint.\n\n\n// TODO: Complete this use statement\nuse std::time::{UNIX_EPOCH, SystemTime};\n\nfn main() {\n    match SystemTime::now().duration_since(UNIX_EPOCH) {\n        Ok(n) =&gt; println!(\"1970-01-01 00:00:00 UTC was {} seconds ago!\", n.as_secs()),\n        Err(_) =&gt; panic!(\"SystemTime before UNIX EPOCH!\"),\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/11.hashmaps/","title":"11.hashmaps","text":""},{"location":"rust/rustlings/11.hashmaps/#hashmaps1rs","title":"hashmaps1.rs","text":"<p>Github solution link <pre><code>// hashmaps1.rs\n//\n// A basket of fruits in the form of a hash map needs to be defined. The key\n// represents the name of the fruit and the value represents how many of that\n// particular fruit is in the basket. You have to put at least three different\n// types of fruits (e.g apple, banana, mango) in the basket and the total count\n// of all the fruits should be at least five.\n//\n// Make me compile and pass the tests!\n//\n// Execute `rustlings hint hashmaps1` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::collections::HashMap;\n\nfn fruit_basket() -&gt; HashMap&lt;String, u32&gt; {\n    let mut basket: HashMap&lt;String, u32&gt; = HashMap::new();\n\n    // Two bananas are already given for you :)\n    basket.insert(String::from(\"banana\"), 2);\n    basket.insert(String::from(\"apple\"), 10);\n    basket.insert(String::from(\"peach\"), 15);\n\n    // TODO: Put more fruits in your basket here.\n\n    basket\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn at_least_three_types_of_fruits() {\n        let basket = fruit_basket();\n        assert!(basket.len() &gt;= 3);\n    }\n\n    #[test]\n    fn at_least_five_fruits() {\n        let basket = fruit_basket();\n        assert!(basket.values().sum::&lt;u32&gt;() &gt;= 5);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/11.hashmaps/#hashmaps2rs","title":"hashmaps2.rs","text":"<p>Github solution link <pre><code>// hashmaps2.rs\n//\n// We're collecting different fruits to bake a delicious fruit cake. For this,\n// we have a basket, which we'll represent in the form of a hash map. The key\n// represents the name of each fruit we collect and the value represents how\n// many of that particular fruit we have collected. Three types of fruits -\n// Apple (4), Mango (2) and Lychee (5) are already in the basket hash map. You\n// must add fruit to the basket so that there is at least one of each kind and\n// more than 11 in total - we have a lot of mouths to feed. You are not allowed\n// to insert any more of these fruits!\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps2` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Hash, PartialEq, Eq)]\nenum Fruit {\n    Apple,\n    Banana,\n    Mango,\n    Lychee,\n    Pineapple,\n}\n\nfn fruit_basket(basket: &amp;mut HashMap&lt;Fruit, u32&gt;) {\n    let fruit_kinds = vec![\n        Fruit::Apple,\n        Fruit::Banana,\n        Fruit::Mango,\n        Fruit::Lychee,\n        Fruit::Pineapple,\n    ];\n\n    for fruit in fruit_kinds {\n        // TODO: Insert new fruits if they are not already present in the\n        // basket. Note that you are not allowed to put any type of fruit that's\n        // already present!\n        if !basket.contains_key(&amp;fruit) {\n            basket.insert(fruit, 5);\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    // Don't modify this function!\n    fn get_fruit_basket() -&gt; HashMap&lt;Fruit, u32&gt; {\n        let mut basket = HashMap::&lt;Fruit, u32&gt;::new();\n        basket.insert(Fruit::Apple, 4);\n        basket.insert(Fruit::Mango, 2);\n        basket.insert(Fruit::Lychee, 5);\n\n        basket\n    }\n\n    #[test]\n    fn test_given_fruits_are_not_modified() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&amp;mut basket);\n        assert_eq!(*basket.get(&amp;Fruit::Apple).unwrap(), 4);\n        assert_eq!(*basket.get(&amp;Fruit::Mango).unwrap(), 2);\n        assert_eq!(*basket.get(&amp;Fruit::Lychee).unwrap(), 5);\n    }\n\n    #[test]\n    fn at_least_five_types_of_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&amp;mut basket);\n        let count_fruit_kinds = basket.len();\n        assert!(count_fruit_kinds &gt;= 5);\n    }\n\n    #[test]\n    fn greater_than_eleven_fruits() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&amp;mut basket);\n        let count = basket.values().sum::&lt;u32&gt;();\n        assert!(count &gt; 11);\n    }\n\n    #[test]\n    fn all_fruit_types_in_basket() {\n        let mut basket = get_fruit_basket();\n        fruit_basket(&amp;mut basket);\n        for amount in basket.values() {\n            assert_ne!(amount, &amp;0);\n        }\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/11.hashmaps/#hashmaps3rs","title":"hashmaps3.rs","text":"<p>Github solution link <pre><code>// hashmaps3.rs\n//\n// A list of scores (one per line) of a soccer match is given. Each line is of\n// the form : \"&lt;team_1_name&gt;,&lt;team_2_name&gt;,&lt;team_1_goals&gt;,&lt;team_2_goals&gt;\"\n// Example: England,France,4,2 (England scored 4 goals, France 2).\n//\n// You have to build a scores table containing the name of the team, goals the\n// team scored, and goals the team conceded. One approach to build the scores\n// table is to use a Hashmap. The solution is partially written to use a\n// Hashmap, complete it to pass the test.\n//\n// Make me pass the tests!\n//\n// Execute `rustlings hint hashmaps3` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::collections::HashMap;\n\n// A structure to store the goal details of a team.\nstruct Team {\n    goals_scored: u8,\n    goals_conceded: u8,\n}\n\n// fn update_score(\n//     scores: &amp;mut HashMap&lt;String, Team&gt;,\n//     team_name: String,\n//     goal_scoreed: u8,\n//     goal_conceded: u8,\n// ) {\n//     let team: &amp;mut Team = scores.entry(team_name.clone()).or_insert(Team {\n//         goals_scored: 0,\n//         goals_conceded: 0,\n//     });\n//     team.goals_conceded += goal_conceded;\n//     team.goals_scored += goal_scoreed;\n// }\n\nfn build_scores_table(results: String) -&gt; HashMap&lt;String, Team&gt; {\n    // The name of the team is the key and its associated struct is the value.\n    let mut scores: HashMap&lt;String, Team&gt; = HashMap::new();\n\n    let mut update_score_fn = |team_name: String, goal_scoreed: u8, goal_conceded: u8|  {\n        let team: &amp;mut Team = scores.entry(team_name.clone()).or_insert(Team {\n            goals_scored: 0,\n            goals_conceded: 0,\n        });\n        team.goals_conceded += goal_conceded;\n        team.goals_scored += goal_scoreed;\n\n    };\n\n    for r in results.lines() {\n        let v: Vec&lt;&amp;str&gt; = r.split(',').collect();\n        let team_1_name = v[0].to_string();\n        let team_1_score: u8 = v[2].parse().unwrap();\n        let team_2_name = v[1].to_string();\n        let team_2_score: u8 = v[3].parse().unwrap();\n        // TODO: Populate the scores table with details extracted from the\n        // current line. Keep in mind that goals scored by team_1\n        // will be the number of goals conceded from team_2, and similarly\n        // goals scored by team_2 will be the number of goals conceded by\n        // team_1.\n\n        update_score_fn(team_1_name, team_1_score, team_2_score);\n        update_score_fn(team_2_name, team_2_score, team_1_score);\n    }\n    scores\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    fn get_results() -&gt; String {\n        let results = \"\".to_string()\n            + \"England,France,4,2\\n\"\n            + \"France,Italy,3,1\\n\"\n            + \"Poland,Spain,2,0\\n\"\n            + \"Germany,England,2,1\\n\";\n        results\n    }\n\n    #[test]\n    fn build_scores() {\n        let scores = build_scores_table(get_results());\n\n        let mut keys: Vec&lt;&amp;String&gt; = scores.keys().collect();\n        keys.sort();\n        assert_eq!(\n            keys,\n            vec![\"England\", \"France\", \"Germany\", \"Italy\", \"Poland\", \"Spain\"]\n        );\n    }\n\n    #[test]\n    fn validate_team_score_1() {\n        let scores = build_scores_table(get_results());\n        let team = scores.get(\"England\").unwrap();\n        assert_eq!(team.goals_scored, 5);\n        assert_eq!(team.goals_conceded, 4);\n    }\n\n    #[test]\n    fn validate_team_score_2() {\n        let scores = build_scores_table(get_results());\n        let team = scores.get(\"Spain\").unwrap();\n        assert_eq!(team.goals_scored, 0);\n        assert_eq!(team.goals_conceded, 2);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/12.options/","title":"12.options","text":""},{"location":"rust/rustlings/12.options/#options1rs","title":"options1.rs","text":"<p>Github solution link <pre><code>// options1.rs\n//\n// Execute `rustlings hint options1` or use the `hint` watch subcommand for a\n// hint.\n\n\n// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(time_of_day: u16) -&gt; Option&lt;u16&gt; {\n    // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a\n    // value of 0 The Option output should gracefully handle cases where\n    // time_of_day &gt; 23.\n    // TODO: Complete the function body - remember to return an Option!\n    if time_of_day &lt; 22 {\n        Some(5)\n    } else if time_of_day &lt;= 24 {\n        Some(0)\n    } else {\n        None\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn check_icecream() {\n        assert_eq!(maybe_icecream(9), Some(5));\n        assert_eq!(maybe_icecream(10), Some(5));\n        assert_eq!(maybe_icecream(23), Some(0));\n        assert_eq!(maybe_icecream(22), Some(0));\n        assert_eq!(maybe_icecream(25), None);\n    }\n\n    #[test]\n    fn raw_value() {\n        // TODO: Fix this test. How do you get at the value contained in the\n        // Option?\n        let icecreams = maybe_icecream(12);\n        assert_eq!(icecreams.unwrap(), 5);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/12.options/#options2rs","title":"options2.rs","text":"<p>Github solution link <pre><code>// options2.rs\n//\n// Execute `rustlings hint options2` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn simple_option() {\n        let target = \"rustlings\";\n        let optional_target = Some(target);\n        // let optional_target: Option&lt;String&gt; = None;\n\n        // TODO: Make this an if let statement whose value is \"Some\" type\n        if let Some(word) = optional_target {\n            assert_eq!(word, target);\n        } else {\n            panic!(\"optional_target is empty\");\n        };\n    }\n\n    #[test]\n    fn layered_option() {\n        let range = 10;\n        let mut optional_integers: Vec&lt;Option&lt;i8&gt;&gt; = vec![None];\n\n        for i in 1..(range + 1) {\n            optional_integers.push(Some(i));\n        }\n\n        let mut cursor = range;\n\n        // TODO: make this a while let statement - remember that vector.pop also\n        // adds another layer of Option&lt;T&gt;. You can stack `Option&lt;T&gt;`s into\n        // while let and if let.\n        while let Some(Some(integer)) = optional_integers.pop() {\n            assert_eq!(integer, cursor);\n            cursor -= 1;\n        }\n\n        assert_eq!(cursor, 0);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/12.options/#options3rs","title":"options3.rs","text":"<p>Github solution link <pre><code>// options3.rs\n//\n// Execute `rustlings hint options3` or use the `hint` watch subcommand for a\n// hint.\n\n\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let y: Option&lt;Point&gt; = Some(Point { x: 100, y: 200 });\n    // let y: Option&lt;(i32, i32)&gt; = Some((1, 2));\n\n    match y {\n        // Some(p) =&gt; println!(\"Co-ordinates are {},{} \", p.0, p.1),\n        Some(ref p) =&gt; println!(\"Co-ordinates are {},{} \", p.x, p.y),\n        _ =&gt; panic!(\"no match!\"),\n    }\n    y; // Fix without deleting this line.\n}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/","title":"13.error handling","text":""},{"location":"rust/rustlings/13.error_handling/#errors1rs","title":"errors1.rs","text":"<p>Github solution link <pre><code>// errors1.rs\n//\n// This function refuses to generate text to be printed on a nametag if you pass\n// it an empty string. It'd be nicer if it explained what the problem was,\n// instead of just sometimes returning `None`. Thankfully, Rust has a similar\n// construct to `Option` that can be used to express error conditions. Let's use\n// it!\n//\n// Execute `rustlings hint errors1` or use the `hint` watch subcommand for a\n// hint.\n\n\npub fn generate_nametag_text(name: String) -&gt; Result&lt;String, String&gt; {\n    if name.is_empty() {\n        // Empty names aren't allowed.\n        Err(\"`name` was empty; it must be nonempty.\".to_string())\n    } else {\n        Ok(format!(\"Hi! My name is {}\", name))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn generates_nametag_text_for_a_nonempty_name() {\n        assert_eq!(\n            generate_nametag_text(\"Beyonc\u00e9\".into()),\n            Ok(\"Hi! My name is Beyonc\u00e9\".into())\n        );\n    }\n\n    #[test]\n    fn explains_why_generating_nametag_text_fails() {\n        assert_eq!(\n            generate_nametag_text(\"\".into()),\n            // Don't change this line\n            Err(\"`name` was empty; it must be nonempty.\".into())\n        );\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/#errors2rs","title":"errors2.rs","text":"<p>Github solution link <pre><code>// errors2.rs\n//\n// Say we're writing a game where you can buy items with tokens. All items cost\n// 5 tokens, and whenever you purchase items there is a processing fee of 1\n// token. A player of the game will type in how many items they want to buy, and\n// the `total_cost` function will calculate the total cost of the items. Since\n// the player typed in the quantity, though, we get it as a string-- and they\n// might have typed anything, not just numbers!\n//\n// Right now, this function isn't handling the error case at all (and isn't\n// handling the success case properly either). What we want to do is: if we call\n// the `total_cost` function on a string that is not a number, that function\n// will return a `ParseIntError`, and in that case, we want to immediately\n// return that error from our function and not try to multiply and add.\n//\n// There are at least two ways to implement this that are both correct-- but one\n// is a lot shorter!\n//\n// Execute `rustlings hint errors2` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::num::ParseIntError;\n\npub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {\n    let processing_fee = 1;\n    let cost_per_item = 5;\n    let qty = item_quantity.parse::&lt;i32&gt;()?;\n\n    Ok(qty * cost_per_item + processing_fee)\n\n    // let qty = item_quantity.parse::&lt;i32&gt;();\n    // match qty {\n    //     Ok(value) =&gt; Ok(value * cost_per_item + processing_fee),\n    //     Err(ParseIntError) =&gt; Err(ParseIntError)\n    // }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn item_quantity_is_a_valid_number() {\n        assert_eq!(total_cost(\"34\"), Ok(171));\n    }\n\n    #[test]\n    fn item_quantity_is_an_invalid_number() {\n        assert_eq!(\n            total_cost(\"beep boop\").unwrap_err().to_string(),\n            \"invalid digit found in string\"\n        );\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/#errors3rs","title":"errors3.rs","text":"<p>Github solution link <pre><code>// errors3.rs\n//\n// This is a program that is trying to use a completed version of the\n// `total_cost` function from the previous exercise. It's not working though!\n// Why not? What should we do to fix it?\n//\n// Execute `rustlings hint errors3` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::num::ParseIntError;\n\nfn main() -&gt; Result&lt;(), ParseIntError&gt; {\n    let mut tokens = 100;\n    let pretend_user_input = \"8\";\n\n    let cost = total_cost(pretend_user_input)?;\n\n    if cost &gt; tokens {\n        println!(\"You can't afford that many!\");\n    } else {\n        tokens -= cost;\n        println!(\"You now have {} tokens.\", tokens);\n    }\n\n    Ok(())\n}\n\npub fn total_cost(item_quantity: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {\n    let processing_fee = 1;\n    let cost_per_item = 5;\n    let qty = item_quantity.parse::&lt;i32&gt;()?;\n\n    Ok(qty * cost_per_item + processing_fee)\n}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/#errors4rs","title":"errors4.rs","text":"<p>Github solution link <pre><code>// errors4.rs\n//\n// Execute `rustlings hint errors4` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {\n        // Hmm... Why is this always returning an Ok value?\n        if value == 0 {\n            Err(CreationError::Zero)\n        } else if value &lt; 0{\n            Err(CreationError::Negative)\n        } else {\n            Ok(PositiveNonzeroInteger(value as u64))\n        }\n    }\n}\n\n#[test]\nfn test_creation() {\n    assert!(PositiveNonzeroInteger::new(10).is_ok());\n    assert_eq!(\n        Err(CreationError::Negative),\n        PositiveNonzeroInteger::new(-10)\n    );\n    assert_eq!(Err(CreationError::Zero), PositiveNonzeroInteger::new(0));\n}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/#errors5rs","title":"errors5.rs","text":"<p>Github solution link <pre><code>// errors5.rs\n//\n// This program uses an altered version of the code from errors4.\n//\n// This exercise uses some concepts that we won't get to until later in the\n// course, like `Box` and the `From` trait. It's not important to understand\n// them in detail right now, but you can read ahead if you like. For now, think\n// of the `Box&lt;dyn ???&gt;` type as an \"I want anything that does ???\" type, which,\n// given Rust's usual standards for runtime safety, should strike you as\n// somewhat lenient!\n//\n// In short, this particular use case for boxes is for when you want to own a\n// value and you care only that it is a type which implements a particular\n// trait. To do so, The Box is declared as of type Box&lt;dyn Trait&gt; where Trait is\n// the trait the compiler looks for on any value used in that context. For this\n// exercise, that context is the potential errors which can be returned in a\n// Result.\n//\n// What can we use to describe both errors? In other words, is there a trait\n// which both errors implement?\n//\n// Execute `rustlings hint errors5` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::error;\nuse std::fmt;\nuse std::num::ParseIntError;\n\n// TODO: update the return type of `main()` to make this compile.\nfn main() -&gt; Result&lt;(), Box&lt;dyn error::Error&gt;&gt; {\n    let pretend_user_input = \"42\";\n    let x: i64 = pretend_user_input.parse()?;\n    println!(\"output={:?}\", PositiveNonzeroInteger::new(x)?);\n    Ok(())\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {\n        match value {\n            x if x &lt; 0 =&gt; Err(CreationError::Negative),\n            x if x == 0 =&gt; Err(CreationError::Zero),\n            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),\n        }\n    }\n}\n\n// This is required so that `CreationError` can implement `error::Error`.\nimpl fmt::Display for CreationError {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        let description = match *self {\n            CreationError::Negative =&gt; \"number is negative\",\n            CreationError::Zero =&gt; \"number is zero\",\n        };\n        f.write_str(description)\n    }\n}\n\nimpl error::Error for CreationError {}\n</code></pre></p>"},{"location":"rust/rustlings/13.error_handling/#errors6rs","title":"errors6.rs","text":"<p>Github solution link <pre><code>// errors6.rs\n//\n// Using catch-all error types like `Box&lt;dyn error::Error&gt;` isn't recommended\n// for library code, where callers might want to make decisions based on the\n// error content, instead of printing it out or propagating it further. Here, we\n// define a custom error type to make it possible for callers to decide what to\n// do next when our function returns an error.\n//\n// Execute `rustlings hint errors6` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::num::ParseIntError;\n\n// This is a custom error type that we will be using in `parse_pos_nonzero()`.\n#[derive(PartialEq, Debug)]\nenum ParsePosNonzeroError {\n    Creation(CreationError),\n    ParseInt(ParseIntError),\n}\n\nimpl ParsePosNonzeroError {\n    fn from_creation(err: CreationError) -&gt; ParsePosNonzeroError {\n        ParsePosNonzeroError::Creation(err)\n    }\n    // TODO: add another error conversion function here.\n    fn from_parseint(err: ParseIntError) -&gt; ParsePosNonzeroError {\n        ParsePosNonzeroError::ParseInt(err)\n    }\n}\n\nfn parse_pos_nonzero(s: &amp;str) -&gt; Result&lt;PositiveNonzeroInteger, ParsePosNonzeroError&gt; {\n    // TODO: change this to return an appropriate error instead of panicking\n    // when `parse()` returns an error.\n    let x: i64 = s.parse().map_err(ParsePosNonzeroError::from_parseint)?;\n    PositiveNonzeroInteger::new(x).map_err(ParsePosNonzeroError::from_creation)\n}\n\n// Don't change anything below this line.\n\n#[derive(PartialEq, Debug)]\nstruct PositiveNonzeroInteger(u64);\n\n#[derive(PartialEq, Debug)]\nenum CreationError {\n    Negative,\n    Zero,\n}\n\nimpl PositiveNonzeroInteger {\n    fn new(value: i64) -&gt; Result&lt;PositiveNonzeroInteger, CreationError&gt; {\n        match value {\n            x if x &lt; 0 =&gt; Err(CreationError::Negative),\n            x if x == 0 =&gt; Err(CreationError::Zero),\n            x =&gt; Ok(PositiveNonzeroInteger(x as u64)),\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::*;\n\n    #[test]\n    fn test_parse_error() {\n        // We can't construct a ParseIntError, so we have to pattern match.\n        assert!(matches!(\n            parse_pos_nonzero(\"not a number\"),\n            Err(ParsePosNonzeroError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn test_negative() {\n        assert_eq!(\n            parse_pos_nonzero(\"-555\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Negative))\n        );\n    }\n\n    #[test]\n    fn test_zero() {\n        assert_eq!(\n            parse_pos_nonzero(\"0\"),\n            Err(ParsePosNonzeroError::Creation(CreationError::Zero))\n        );\n    }\n\n    #[test]\n    fn test_positive() {\n        let x = PositiveNonzeroInteger::new(42);\n        assert!(x.is_ok());\n        assert_eq!(parse_pos_nonzero(\"42\"), Ok(x.unwrap()));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/14.generics/","title":"14.generics","text":""},{"location":"rust/rustlings/14.generics/#generics1rs","title":"generics1.rs","text":"<p>Github solution link <pre><code>// generics1.rs\n//\n// This shopping list program isn't compiling! Use your knowledge of generics to\n// fix it.\n//\n// Execute `rustlings hint generics1` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn main() {\n    let mut shopping_list: Vec&lt;&amp;str&gt; = Vec::new();\n    shopping_list.push(\"milk\");\n}\n</code></pre></p>"},{"location":"rust/rustlings/14.generics/#generics2rs","title":"generics2.rs","text":"<p>Github solution link <pre><code>// generics2.rs\n//\n// This powerful wrapper provides the ability to store a positive integer value.\n// Rewrite it using generics so that it supports wrapping ANY type.\n//\n// Execute `rustlings hint generics2` or use the `hint` watch subcommand for a\n// hint.\n\n\nstruct Wrapper&lt;T&gt; {\n    value: T,\n}\n\nimpl&lt;T&gt; Wrapper&lt;T&gt; {\n    pub fn new(value: T) -&gt; Self {\n        Wrapper { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn store_u32_in_wrapper() {\n        assert_eq!(Wrapper::new(42).value, 42);\n    }\n\n    #[test]\n    fn store_str_in_wrapper() {\n        assert_eq!(Wrapper::new(\"Foo\").value, \"Foo\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/15.traits/","title":"15.traits","text":""},{"location":"rust/rustlings/15.traits/#traits1rs","title":"traits1.rs","text":"<p>Github solution link <pre><code>// traits1.rs\n//\n// Time to implement some traits! Your task is to implement the trait\n// `AppendBar` for the type `String`. The trait AppendBar has only one function,\n// which appends \"Bar\" to any object implementing this trait.\n//\n// Execute `rustlings hint traits1` or use the `hint` watch subcommand for a\n// hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -&gt; Self;\n}\n\nimpl AppendBar for String {\n    // TODO: Implement `AppendBar` for type `String`.\n\n    fn append_bar(self: String) -&gt; String {\n        format!(\"{}Bar\", self).to_string()\n    }\n}\n\nfn main() {\n    let s = String::from(\"Foo\");\n    let s = s.append_bar();\n    println!(\"s: {}\", s);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_foo_bar() {\n        assert_eq!(String::from(\"Foo\").append_bar(), String::from(\"FooBar\"));\n    }\n\n    #[test]\n    fn is_bar_bar() {\n        assert_eq!(\n            String::from(\"\").append_bar().append_bar(),\n            String::from(\"BarBar\")\n        );\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/15.traits/#traits2rs","title":"traits2.rs","text":"<p>Github solution link <pre><code>// traits2.rs\n//\n// Your task is to implement the trait `AppendBar` for a vector of strings. To\n// implement this trait, consider for a moment what it means to 'append \"Bar\"'\n// to a vector of strings.\n//\n// No boiler plate code this time, you can do this!\n//\n// Execute `rustlings hint traits2` or use the `hint` watch subcommand for a hint.\n\n\ntrait AppendBar {\n    fn append_bar(self) -&gt; Self;\n}\n\n// TODO: Implement trait `AppendBar` for a vector of strings.\n\nimpl AppendBar for Vec&lt;String&gt; {\n    fn append_bar(mut self: Vec&lt;String&gt;) -&gt; Vec&lt;String&gt; {\n        self.push(\"Bar\".to_string());\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_vec_pop_eq_bar() {\n        let mut foo = vec![String::from(\"Foo\")].append_bar();\n        assert_eq!(foo.pop().unwrap(), String::from(\"Bar\"));\n        assert_eq!(foo.pop().unwrap(), String::from(\"Foo\"));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/15.traits/#traits3rs","title":"traits3.rs","text":"<p>Github solution link <pre><code>// traits3.rs\n//\n// Your task is to implement the Licensed trait for both structures and have\n// them return the same information without writing the same function twice.\n//\n// Consider what you can add to the Licensed trait.\n//\n// Execute `rustlings hint traits3` or use the `hint` watch subcommand for a\n// hint.\n\n\npub trait Licensed {\n    fn licensing_info(&amp;self) -&gt; String {\n        String::from(\"Some information\")\n    }\n}\n\nstruct SomeSoftware {\n    version_number: i32,\n}\n\nstruct OtherSoftware {\n    version_number: String,\n}\n\nimpl Licensed for SomeSoftware {} // Don't edit this line\nimpl Licensed for OtherSoftware {} // Don't edit this line\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_licensing_info_the_same() {\n        let licensing_info = String::from(\"Some information\");\n        let some_software = SomeSoftware { version_number: 1 };\n        let other_software = OtherSoftware {\n            version_number: \"v2.0.0\".to_string(),\n        };\n        assert_eq!(some_software.licensing_info(), licensing_info);\n        assert_eq!(other_software.licensing_info(), licensing_info);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/15.traits/#traits4rs","title":"traits4.rs","text":"<p>Github solution link <pre><code>// traits4.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n//\n// Don't change any line other than the marked one.\n//\n// Execute `rustlings hint traits4` or use the `hint` watch subcommand for a\n// hint.\n\n\npub trait Licensed {\n    fn licensing_info(&amp;self) -&gt; String {\n        \"some information\".to_string()\n    }\n}\n\nstruct SomeSoftware {}\n\nstruct OtherSoftware {}\n\nimpl Licensed for SomeSoftware {}\nimpl Licensed for OtherSoftware {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn compare_license_types&lt;T: Licensed, U: Licensed&gt;(software: T, software_two: U) -&gt; bool {\n    software.licensing_info() == software_two.licensing_info()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn compare_license_information() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(some_software, other_software));\n    }\n\n    #[test]\n    fn compare_license_information_backwards() {\n        let some_software = SomeSoftware {};\n        let other_software = OtherSoftware {};\n\n        assert!(compare_license_types(other_software, some_software));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/15.traits/#traits5rs","title":"traits5.rs","text":"<p>Github solution link <pre><code>// traits5.rs\n//\n// Your task is to replace the '??' sections so the code compiles.\n//\n// Don't change any line other than the marked one.\n//\n// Execute `rustlings hint traits5` or use the `hint` watch subcommand for a\n// hint.\n\n\npub trait SomeTrait {\n    fn some_function(&amp;self) -&gt; bool {\n        true\n    }\n}\n\npub trait OtherTrait {\n    fn other_function(&amp;self) -&gt; bool {\n        true\n    }\n}\n\nstruct SomeStruct {}\nstruct OtherStruct {}\n\nimpl SomeTrait for SomeStruct {}\nimpl OtherTrait for SomeStruct {}\nimpl SomeTrait for OtherStruct {}\nimpl OtherTrait for OtherStruct {}\n\n// YOU MAY ONLY CHANGE THE NEXT LINE\nfn some_func&lt;T: SomeTrait + OtherTrait&gt;(item: T) -&gt; bool {\n    item.some_function() &amp;&amp; item.other_function()\n}\n\nfn main() {\n    some_func(SomeStruct {});\n    some_func(OtherStruct {});\n}\n</code></pre></p>"},{"location":"rust/rustlings/16.lifetimes/","title":"16.lifetimes","text":""},{"location":"rust/rustlings/16.lifetimes/#lifetimes1rs","title":"lifetimes1.rs","text":"<p>Github solution link <pre><code>// lifetimes1.rs\n//\n// The Rust compiler needs to know how to check whether supplied references are\n// valid, so that it can let the programmer know if a reference is at risk of\n// going out of scope before it is used. Remember, references are borrows and do\n// not own their own data. What if their owner goes out of scope?\n//\n// Execute `rustlings hint lifetimes1` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is '{}'\", result);\n\n}\n</code></pre></p>"},{"location":"rust/rustlings/16.lifetimes/#lifetimes2rs","title":"lifetimes2.rs","text":"<p>Github solution link <pre><code>// lifetimes2.rs\n//\n// So if the compiler is just validating the references passed to the annotated\n// parameters and the return type, what do we need to change?\n//\n// Execute `rustlings hint lifetimes2` or use the `hint` watch subcommand for a\n// hint.\n\n\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result: &amp;str;\n    let string2;\n    {\n        string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is '{}'\", result);\n}\n</code></pre></p>"},{"location":"rust/rustlings/16.lifetimes/#lifetimes3rs","title":"lifetimes3.rs","text":"<p>Github solution link <pre><code>// lifetimes3.rs\n//\n// Lifetimes are also needed when structs hold references.\n//\n// Execute `rustlings hint lifetimes3` or use the `hint` watch subcommand for a\n// hint.\n\n\nstruct Book&lt;'a&gt; {\n    author: &amp;'a str,\n    title: &amp;'a str,\n}\n\nfn main() {\n    let name = String::from(\"Jill Smith\");\n    let title = String::from(\"Fish Flying\");\n    let book = Book { author: &amp;name, title: &amp;title };\n\n    println!(\"{} by {}\", book.title, book.author);\n}\n</code></pre></p>"},{"location":"rust/rustlings/17.tests/","title":"17.tests","text":""},{"location":"rust/rustlings/17.tests/#tests1rs","title":"tests1.rs","text":"<p>Github solution link <pre><code>// tests1.rs\n//\n// Tests are important to ensure that your code does what you think it should\n// do. Tests can be run on this file with the following command: rustlings run\n// tests1\n//\n// This test has a problem with it -- make the test compile! Make the test pass!\n// Make the test fail!\n//\n// Execute `rustlings hint tests1` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert() {\n        assert!(true);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/17.tests/#tests2rs","title":"tests2.rs","text":"<p>Github solution link <pre><code>// tests2.rs\n//\n// This test has a problem with it -- make the test compile! Make the test pass!\n// Make the test fail!\n//\n// Execute `rustlings hint tests2` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn you_can_assert_eq() {\n        assert_eq!(1, 1);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/17.tests/#tests3rs","title":"tests3.rs","text":"<p>Github solution link <pre><code>// tests3.rs\n//\n// This test isn't testing our function -- make it do that in such a way that\n// the test passes. Then write a second test that tests whether we get the\n// result we expect to get when we call `is_even(5)`.\n//\n// Execute `rustlings hint tests3` or use the `hint` watch subcommand for a\n// hint.\n\n\npub fn is_even(num: i32) -&gt; bool {\n    num % 2 == 0\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn is_true_when_even() {\n        assert!(is_even(4));\n    }\n\n    #[test]\n    fn is_false_when_odd() {\n        assert!(!is_even(5));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/17.tests/#tests4rs","title":"tests4.rs","text":"<p>Github solution link <pre><code>// tests4.rs\n//\n// Make sure that we're testing for the correct conditions!\n//\n// Execute `rustlings hint tests4` or use the `hint` watch subcommand for a\n// hint.\n\n\nstruct Rectangle {\n    width: i32,\n    height: i32\n}\n\nimpl Rectangle {\n    // Only change the test functions themselves\n    pub fn new(width: i32, height: i32) -&gt; Result&lt;Rectangle, String&gt; {\n        if width &lt;= 0 || height &lt;= 0 {\n            Err(String::from(\"Rectangle width and height cannot be negative!\"))\n        } else {\n            Ok(Rectangle {width, height})\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn correct_width_and_height() {\n        // This test should check if the rectangle is the size that we pass into its constructor\n        let rect = Rectangle::new(10, 20).unwrap();\n        assert_eq!(rect.width, 10); // check width\n        assert_eq!(rect.height, 20); // check height\n    }\n\n    #[test]\n    fn negative_width() {\n        // This test should check if program panics when we try to create rectangle with negative width\n        let _rect = Rectangle::new(-10, 10);\n        assert!(_rect.is_err());\n    }\n\n    #[test]\n    fn negative_height() {\n        // This test should check if program panics when we try to create rectangle with negative height\n        let _rect = Rectangle::new(10, -10);\n        assert!(_rect.is_err());\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/18.iterators/","title":"18.iterators","text":""},{"location":"rust/rustlings/18.iterators/#iterators1rs","title":"iterators1.rs","text":"<p>Github solution link <pre><code>// iterators1.rs\n//\n// When performing operations on elements within a collection, iterators are\n// essential. This module helps you get familiar with the structure of using an\n// iterator and how to go through elements within an iterable collection.\n//\n// Make me compile by filling in the `???`s\n//\n// Execute `rustlings hint iterators1` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[test]\nfn main() {\n    let my_fav_fruits = vec![\"banana\", \"custard apple\", \"avocado\", \"peach\", \"raspberry\"];\n\n    let mut my_iterable_fav_fruits = my_fav_fruits.iter().chain(my_fav_fruits.iter());   // TODO: Step 1\n\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"banana\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"custard apple\"));     // TODO: Step 2\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"avocado\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"peach\"));     // TODO: Step 3\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"raspberry\"));\n    assert_eq!(my_iterable_fav_fruits.next(), Some(&amp;\"banana\"));     // TODO: Step 4\n}\n</code></pre></p>"},{"location":"rust/rustlings/18.iterators/#iterators2rs","title":"iterators2.rs","text":"<p>Github solution link <pre><code>// iterators2.rs\n//\n// In this exercise, you'll learn some of the unique advantages that iterators\n// can offer. Follow the steps to complete the exercise.\n//\n// Execute `rustlings hint iterators2` or use the `hint` watch subcommand for a\n// hint.\n\n\n// Step 1.\n// Complete the `capitalize_first` function.\n// \"hello\" -&gt; \"Hello\"\npub fn capitalize_first(input: &amp;str) -&gt; String {\n    let mut c = input.chars();\n    match c.next() {\n        None =&gt; String::new(),\n        Some(first) =&gt; first.to_uppercase().to_string()  + c.as_str(),\n    }\n}\n\n// Step 2.\n// Apply the `capitalize_first` function to a slice of string slices.\n// Return a vector of strings.\n// [\"hello\", \"world\"] -&gt; [\"Hello\", \"World\"]\npub fn capitalize_words_vector(words: &amp;[&amp;str]) -&gt; Vec&lt;String&gt; {\n    words.iter().map(|word| capitalize_first(word)).collect()\n}\n\n// Step 3.\n// Apply the `capitalize_first` function again to a slice of string slices.\n// Return a single string.\n// [\"hello\", \" \", \"world\"] -&gt; \"Hello World\"\npub fn capitalize_words_string(words: &amp;[&amp;str]) -&gt; String {\n    // words.iter().map(|x| capitalize_first(x)).collect::&lt;String&gt;()\n    words.iter().map(|word| capitalize_first(word)).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(capitalize_first(\"hello\"), \"Hello\");\n    }\n\n    #[test]\n    fn test_empty() {\n        assert_eq!(capitalize_first(\"\"), \"\");\n    }\n\n    #[test]\n    fn test_iterate_string_vec() {\n        let words = vec![\"hello\", \"world\"];\n        assert_eq!(capitalize_words_vector(&amp;words), [\"Hello\", \"World\"]);\n    }\n\n    #[test]\n    fn test_iterate_into_string() {\n        let words = vec![\"hello\", \" \", \"world\"];\n        assert_eq!(capitalize_words_string(&amp;words), \"Hello World\");\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/18.iterators/#iterators3rs","title":"iterators3.rs","text":"<p>Github solution link <pre><code>// iterators3.rs\n//\n// This is a bigger exercise than most of the others! You can do it! Here is\n// your mission, should you choose to accept it:\n// 1. Complete the divide function to get the first four tests to pass.\n// 2. Get the remaining tests to pass by completing the result_with_list and\n//    list_of_results functions.\n//\n// Execute `rustlings hint iterators3` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[derive(Debug, PartialEq, Eq)]\npub enum DivisionError {\n    NotDivisible(NotDivisibleError),\n    DivideByZero,\n}\n\n#[derive(Debug, PartialEq, Eq)]\npub struct NotDivisibleError {\n    dividend: i32,\n    divisor: i32,\n}\n\n// Calculate `a` divided by `b` if `a` is evenly divisible by `b`.\n// Otherwise, return a suitable error.\npub fn divide(a: i32, b: i32) -&gt; Result&lt;i32, DivisionError&gt; {\n    if b == 0 {\n        Err(DivisionError::DivideByZero)\n    } else if a % b == 0 {\n        Ok(a / b)\n    } else {\n        Err(DivisionError::NotDivisible(NotDivisibleError {\n            dividend: a,\n            divisor: b,\n        }))\n    }\n}\n\n// Complete the function and return a value of the correct type so the test\n// passes.\n// Desired output: Ok([1, 11, 1426, 3])\nfn result_with_list() -&gt; Result&lt;Vec&lt;i32&gt;, DivisionError&gt; {\n    let numbers = vec![27, 297, 38502, 81];\n    let division_results = numbers.into_iter().map(|n| divide(n, 27)).collect();\n    division_results\n}\n\n// Complete the function and return a value of the correct type so the test\n// passes.\n// Desired output: [Ok(1), Ok(11), Ok(1426), Ok(3)]\nfn list_of_results() -&gt; Vec&lt;Result&lt;i32, DivisionError&gt;&gt;  {\n    let numbers = vec![27, 297, 38502, 81];\n    let division_results = numbers.into_iter().map(|n| divide(n, 27)).collect();\n    division_results\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_success() {\n        assert_eq!(divide(81, 9), Ok(9));\n    }\n\n    #[test]\n    fn test_not_divisible() {\n        assert_eq!(\n            divide(81, 6),\n            Err(DivisionError::NotDivisible(NotDivisibleError {\n                dividend: 81,\n                divisor: 6\n            }))\n        );\n    }\n\n    #[test]\n    fn test_divide_by_0() {\n        assert_eq!(divide(81, 0), Err(DivisionError::DivideByZero));\n    }\n\n    #[test]\n    fn test_divide_0_by_something() {\n        assert_eq!(divide(0, 81), Ok(0));\n    }\n\n    #[test]\n    fn test_result_with_list() {\n        assert_eq!(format!(\"{:?}\", result_with_list()), \"Ok([1, 11, 1426, 3])\");\n    }\n\n    #[test]\n    fn test_list_of_results() {\n        assert_eq!(\n            format!(\"{:?}\", list_of_results()),\n            \"[Ok(1), Ok(11), Ok(1426), Ok(3)]\"\n        );\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/18.iterators/#iterators4rs","title":"iterators4.rs","text":"<p>Github solution link <pre><code>// iterators4.rs\n//\n// Execute `rustlings hint iterators4` or use the `hint` watch subcommand for a\n// hint.\n\n\npub fn factorial(num: u64) -&gt; u64 {\n    // Complete this function to return the factorial of num\n    // Do not use:\n    // - return\n    // Try not to use:\n    // - imperative style loops (for, while)\n    // - additional variables\n    // For an extra challenge, don't use:\n    // - recursion\n    // Execute `rustlings hint iterators4` for hints.\n    let nums = std::ops::Range { start: 1, end: num + 1 };\n    nums.fold(1, |acc, x| acc * x)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn factorial_of_0() {\n        assert_eq!(1, factorial(0));\n    }\n\n    #[test]\n    fn factorial_of_1() {\n        assert_eq!(1, factorial(1));\n    }\n    #[test]\n    fn factorial_of_2() {\n        assert_eq!(2, factorial(2));\n    }\n\n    #[test]\n    fn factorial_of_4() {\n        assert_eq!(24, factorial(4));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/18.iterators/#iterators5rs","title":"iterators5.rs","text":"<p>Github solution link <pre><code>// iterators5.rs\n//\n// Let's define a simple model to track Rustlings exercise progress. Progress\n// will be modelled using a hash map. The name of the exercise is the key and\n// the progress is the value. Two counting functions were created to count the\n// number of exercises with a given progress. Recreate this counting\n// functionality using iterators. Try not to use imperative loops (for, while).\n// Only the two iterator methods (count_iterator and count_collection_iterator)\n// need to be modified.\n//\n// Execute `rustlings hint iterators5` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::collections::HashMap;\n\n#[derive(Clone, Copy, PartialEq, Eq)]\nenum Progress {\n    None,\n    Some,\n    Complete,\n}\n\nfn count_for(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {\n    let mut count = 0;\n    for val in map.values() {\n        if val == &amp;value {\n            count += 1;\n        }\n    }\n    count\n}\n\nfn count_iterator(map: &amp;HashMap&lt;String, Progress&gt;, value: Progress) -&gt; usize {\n    // map is a hashmap with String keys and Progress values.\n    // map = { \"variables1\": Complete, \"from_str\": None, ... }\n    map.iter().filter(|x| x.1 == &amp;value).count()\n}\n\nfn count_collection_for(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {\n    let mut count = 0;\n    for map in collection {\n        for val in map.values() {\n            if val == &amp;value {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nfn count_collection_iterator(collection: &amp;[HashMap&lt;String, Progress&gt;], value: Progress) -&gt; usize {\n    // collection is a slice of hashmaps.\n    // collection = [{ \"variables1\": Complete, \"from_str\": None, ... },\n    //     { \"variables2\": Complete, ... }, ... ]\n    collection\n        .iter()\n        .map(|map| map.iter().filter(|x| x.1 == &amp;value).count())\n        .fold(0, |acc, x| x + acc)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn count_complete() {\n        let map = get_map();\n        assert_eq!(3, count_iterator(&amp;map, Progress::Complete));\n    }\n\n    #[test]\n    fn count_some() {\n        let map = get_map();\n        assert_eq!(1, count_iterator(&amp;map, Progress::Some));\n    }\n\n    #[test]\n    fn count_none() {\n        let map = get_map();\n        assert_eq!(2, count_iterator(&amp;map, Progress::None));\n    }\n\n    #[test]\n    fn count_complete_equals_for() {\n        let map = get_map();\n        let progress_states = vec![Progress::Complete, Progress::Some, Progress::None];\n        for progress_state in progress_states {\n            assert_eq!(\n                count_for(&amp;map, progress_state),\n                count_iterator(&amp;map, progress_state)\n            );\n        }\n    }\n\n    #[test]\n    fn count_collection_complete() {\n        let collection = get_vec_map();\n        assert_eq!(\n            6,\n            count_collection_iterator(&amp;collection, Progress::Complete)\n        );\n    }\n\n    #[test]\n    fn count_collection_some() {\n        let collection = get_vec_map();\n        assert_eq!(1, count_collection_iterator(&amp;collection, Progress::Some));\n    }\n\n    #[test]\n    fn count_collection_none() {\n        let collection = get_vec_map();\n        assert_eq!(4, count_collection_iterator(&amp;collection, Progress::None));\n    }\n\n    #[test]\n    fn count_collection_equals_for() {\n        let progress_states = vec![Progress::Complete, Progress::Some, Progress::None];\n        let collection = get_vec_map();\n\n        for progress_state in progress_states {\n            assert_eq!(\n                count_collection_for(&amp;collection, progress_state),\n                count_collection_iterator(&amp;collection, progress_state)\n            );\n        }\n    }\n\n    fn get_map() -&gt; HashMap&lt;String, Progress&gt; {\n        use Progress::*;\n\n        let mut map = HashMap::new();\n        map.insert(String::from(\"variables1\"), Complete);\n        map.insert(String::from(\"functions1\"), Complete);\n        map.insert(String::from(\"hashmap1\"), Complete);\n        map.insert(String::from(\"arc1\"), Some);\n        map.insert(String::from(\"as_ref_mut\"), None);\n        map.insert(String::from(\"from_str\"), None);\n\n        map\n    }\n\n    fn get_vec_map() -&gt; Vec&lt;HashMap&lt;String, Progress&gt;&gt; {\n        use Progress::*;\n\n        let map = get_map();\n\n        let mut other = HashMap::new();\n        other.insert(String::from(\"variables2\"), Complete);\n        other.insert(String::from(\"functions2\"), Complete);\n        other.insert(String::from(\"if1\"), Complete);\n        other.insert(String::from(\"from_into\"), None);\n        other.insert(String::from(\"try_from_into\"), None);\n\n        vec![map, other]\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/19.smart_pointers/","title":"19.smart pointers","text":""},{"location":"rust/rustlings/19.smart_pointers/#arc1rs","title":"arc1.rs","text":"<p>Github solution link <pre><code>// arc1.rs\n//\n// In this exercise, we are given a Vec of u32 called \"numbers\" with values\n// ranging from 0 to 99 -- [ 0, 1, 2, ..., 98, 99 ] We would like to use this\n// set of numbers within 8 different threads simultaneously. Each thread is\n// going to get the sum of every eighth value, with an offset.\n//\n// The first thread (offset 0), will sum 0, 8, 16, ...\n// The second thread (offset 1), will sum 1, 9, 17, ...\n// The third thread (offset 2), will sum 2, 10, 18, ...\n// ...\n// The eighth thread (offset 7), will sum 7, 15, 23, ...\n//\n// Because we are using threads, our values need to be thread-safe.  Therefore,\n// we are using Arc.  We need to make a change in each of the two TODOs.\n//\n// Make this code compile by filling in a value for `shared_numbers` where the\n// first TODO comment is, and create an initial binding for `child_numbers`\n// where the second TODO comment is. Try not to create any copies of the\n// `numbers` Vec!\n//\n// Execute `rustlings hint arc1` or use the `hint` watch subcommand for a hint.\n\n\n#![forbid(unused_imports)] // Do not change this, (or the next) line.\nuse std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let numbers: Vec&lt;_&gt; = (0..100u32).collect();\n    let shared_numbers = Arc::new(numbers);\n    let mut joinhandles = Vec::new();\n\n    for offset in 0..8 {\n        let child_numbers = shared_numbers.clone();\n        joinhandles.push(thread::spawn(move || {\n            let sum: u32 = child_numbers.iter().filter(|&amp;&amp;n| n % 8 == offset).sum();\n            println!(\"Sum of offset {} is {}\", offset, sum);\n            sum\n        }));\n    }\n    let mut total = 0;\n    for handle in joinhandles.into_iter() {\n        total += handle.join().unwrap();\n    }\n    assert_eq!(total, (99 * 100) / 2)\n}\n</code></pre></p>"},{"location":"rust/rustlings/19.smart_pointers/#box1rs","title":"box1.rs","text":"<p>Github solution link <pre><code>// box1.rs\n//\n// At compile time, Rust needs to know how much space a type takes up. This\n// becomes problematic for recursive types, where a value can have as part of\n// itself another value of the same type. To get around the issue, we can use a\n// `Box` - a smart pointer used to store data on the heap, which also allows us\n// to wrap a recursive type.\n//\n// The recursive type we're implementing in this exercise is the `cons list` - a\n// data structure frequently found in functional programming languages. Each\n// item in a cons list contains two elements: the value of the current item and\n// the next item. The last item is a value called `Nil`.\n//\n// Step 1: use a `Box` in the enum definition to make the code compile\n// Step 2: create both empty and non-empty cons lists by replacing `todo!()`\n//\n// Note: the tests should not be changed\n//\n// Execute `rustlings hint box1` or use the `hint` watch subcommand for a hint.\n\n\n#[derive(PartialEq, Debug)]\npub enum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nfn main() {\n    println!(\"This is an empty cons list: {:?}\", create_empty_list());\n    println!(\n        \"This is a non-empty cons list: {:?}\",\n        create_non_empty_list()\n    );\n}\n\npub fn create_empty_list() -&gt; List {\n    List::Nil\n}\n\npub fn create_non_empty_list() -&gt; List {\n    List::Cons(0, Box::new(List::Nil))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_create_empty_list() {\n        assert_eq!(List::Nil, create_empty_list())\n    }\n\n    #[test]\n    fn test_create_non_empty_list() {\n        assert_ne!(create_empty_list(), create_non_empty_list())\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/19.smart_pointers/#cow1rs","title":"cow1.rs","text":"<p>Github solution link <pre><code>// cow1.rs\n//\n// This exercise explores the Cow, or Clone-On-Write type. Cow is a\n// clone-on-write smart pointer. It can enclose and provide immutable access to\n// borrowed data, and clone the data lazily when mutation or ownership is\n// required. The type is designed to work with general borrowed data via the\n// Borrow trait.\n//\n// This exercise is meant to show you what to expect when passing data to Cow.\n// Fix the unit tests by checking for Cow::Owned(_) and Cow::Borrowed(_) at the\n// TODO markers.\n//\n// Execute `rustlings hint cow1` or use the `hint` watch subcommand for a hint.\n\n\nuse std::borrow::Cow;\n\nfn abs_all&lt;'a, 'b&gt;(input: &amp;'a mut Cow&lt;'b, [i32]&gt;) -&gt; &amp;'a mut Cow&lt;'b, [i32]&gt; {\n    for i in 0..input.len() {\n        let v = input[i];\n        if v &lt; 0 {\n            // Clones into a vector if not already owned.\n            input.to_mut()[i] = -v;\n        }\n    }\n    input\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn reference_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {\n        // Clone occurs because `input` needs to be mutated.\n        let slice = [-1, 0, 1];\n        let mut input = Cow::from(&amp;slice[..]);\n        match abs_all(&amp;mut input) {\n            Cow::Owned(_) =&gt; Ok(()),\n            _ =&gt; Err(\"Expected owned value\"),\n        }\n    }\n\n    #[test]\n    fn reference_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {\n        // No clone occurs because `input` doesn't need to be mutated.\n        let slice = [0, 1, 2];\n        let mut input = Cow::from(&amp;slice[..]);\n        match abs_all(&amp;mut input) {\n            // TODO\n            Cow::Borrowed(_) =&gt; Ok(()),\n            _ =&gt; Err(\"Expected owned value\"),\n        }\n    }\n\n    #[test]\n    fn owned_no_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {\n        // We can also pass `slice` without `&amp;` so Cow owns it directly. In this\n        // case no mutation occurs and thus also no clone, but the result is\n        // still owned because it was never borrowed or mutated.\n        let slice = vec![0, 1, 2];\n        let mut input = Cow::from(slice);\n        match abs_all(&amp;mut input) {\n            // TODO\n            Cow::Owned(_) =&gt; Ok(()),\n            _ =&gt; Err(\"Expected owned value\"),\n        }\n    }\n\n    #[test]\n    fn owned_mutation() -&gt; Result&lt;(), &amp;'static str&gt; {\n        // Of course this is also the case if a mutation does occur. In this\n        // case the call to `to_mut()` in the abs_all() function returns a\n        // reference to the same data as before.\n        let slice = vec![-1, 0, 1];\n        let mut input = Cow::from(slice);\n        match abs_all(&amp;mut input) {\n            // TODO\n            Cow::Owned(_) =&gt; Ok(()),\n            _ =&gt; Err(\"Expected owned value\"),\n        }\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/19.smart_pointers/#rc1rs","title":"rc1.rs","text":"<p>Github solution link <pre><code>// rc1.rs\n//\n// In this exercise, we want to express the concept of multiple owners via the\n// Rc&lt;T&gt; type. This is a model of our solar system - there is a Sun type and\n// multiple Planets. The Planets take ownership of the sun, indicating that they\n// revolve around the sun.\n//\n// Make this code compile by using the proper Rc primitives to express that the\n// sun has multiple owners.\n//\n// Execute `rustlings hint rc1` or use the `hint` watch subcommand for a hint.\n\n\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Sun {}\n\n#[derive(Debug)]\nenum Planet {\n    Mercury(Rc&lt;Sun&gt;),\n    Venus(Rc&lt;Sun&gt;),\n    Earth(Rc&lt;Sun&gt;),\n    Mars(Rc&lt;Sun&gt;),\n    Jupiter(Rc&lt;Sun&gt;),\n    Saturn(Rc&lt;Sun&gt;),\n    Uranus(Rc&lt;Sun&gt;),\n    Neptune(Rc&lt;Sun&gt;),\n}\n\nimpl Planet {\n    fn details(&amp;self) {\n        println!(\"Hi from {:?}!\", self)\n    }\n}\n\n#[test]\nfn main() {\n    let sun = Rc::new(Sun {});\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 1 reference\n\n    let mercury = Planet::Mercury(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 2 references\n    mercury.details();\n\n    let venus = Planet::Venus(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 3 references\n    venus.details();\n\n    let earth = Planet::Earth(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 4 references\n    earth.details();\n\n    let mars = Planet::Mars(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 5 references\n    mars.details();\n\n    let jupiter = Planet::Jupiter(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 6 references\n    jupiter.details();\n\n    let saturn = Planet::Saturn(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 7 references\n    saturn.details();\n\n    let uranus = Planet::Uranus(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 8 references\n    uranus.details();\n\n    let neptune = Planet::Neptune(Rc::clone(&amp;sun));\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 9 references\n    neptune.details();\n\n    assert_eq!(Rc::strong_count(&amp;sun), 9);\n\n    drop(neptune);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 8 references\n\n    drop(uranus);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 7 references\n\n    drop(saturn);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 6 references\n\n    drop(jupiter);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 5 references\n\n    drop(mars);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 4 references\n\n    drop(earth);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 3 references\n\n    drop(venus);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 2 references\n\n    drop(mercury);\n    println!(\"reference count = {}\", Rc::strong_count(&amp;sun)); // 1 reference\n\n    assert_eq!(Rc::strong_count(&amp;sun), 1);\n}\n</code></pre></p>"},{"location":"rust/rustlings/20.threads/","title":"20.threads","text":""},{"location":"rust/rustlings/20.threads/#threads1rs","title":"threads1.rs","text":"<p>Github solution link <pre><code>// threads1.rs\n//\n// This program spawns multiple threads that each run for at least 250ms, and\n// each thread returns how much time they took to complete. The program should\n// wait until all the spawned threads have finished and should collect their\n// return values into a vector.\n//\n// Execute `rustlings hint threads1` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::thread;\nuse std::time::{Duration, Instant};\n\nfn main() {\n    let mut handles = vec![];\n    for i in 0..10 {\n        handles.push(thread::spawn(move || {\n            let start = Instant::now();\n            thread::sleep(Duration::from_millis(1));\n            println!(\"thread {} is complete\", i);\n            start.elapsed().as_millis()\n        }));\n    }\n\n    let mut results: Vec&lt;u128&gt; = vec![];\n    for handle in handles {\n        match handle.join() {\n            Ok(x) =&gt; results.push(x),\n            Err(_) =&gt; results.push(0),\n        }\n    }\n\n    if results.len() != 10 {\n        panic!(\"Oh no! All the spawned threads did not finish!\");\n    }\n\n    println!();\n    for (i, result) in results.into_iter().enumerate() {\n        println!(\"thread {} took {}ms\", i, result);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/20.threads/#threads2rs","title":"threads2.rs","text":"<p>Github solution link <pre><code>// threads2.rs\n//\n// Building on the last exercise, we want all of the threads to complete their\n// work but this time the spawned threads need to be in charge of updating a\n// shared value: JobStatus.jobs_completed\n//\n// Execute `rustlings hint threads2` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\nstruct JobStatus {\n    jobs_completed: u32,\n}\n\nfn main() {\n    let status = Arc::new(Mutex::new(JobStatus { jobs_completed: 0 }));\n    let mut handles = vec![];\n    for _ in 0..10 {\n        let status_shared = Arc::clone(&amp;status);\n        let handle = thread::spawn(move || {\n            thread::sleep(Duration::from_millis(250));\n            let mut locked_status = status_shared.lock().unwrap();\n            // TODO: You must take an action before you update a shared value\n            locked_status.jobs_completed += 1;\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n        // TODO: Print the value of the JobStatus.jobs_completed. Did you notice\n        // anything interesting in the output? Do you have to 'join' on all the\n        // handles?\n\n\n        // Output:\n        // ====================\n        // jobs completed 1\n        // jobs completed 2\n        // jobs completed 3\n        // jobs completed 4\n        // jobs completed 5\n        // jobs completed 6\n        // jobs completed 10\n        // jobs completed 10\n        // jobs completed 10\n        // jobs completed 10\n\n        // ====================\n        // By the time 6th thread completes, all the other tasks are completed.\n\n        let mut locked_read_only_status = status.lock().unwrap();\n        println!(\"jobs completed {}\", locked_read_only_status.jobs_completed);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/20.threads/#threads3rs","title":"threads3.rs","text":"<p>Github solution link <pre><code>// threads3.rs\n//\n// Execute `rustlings hint threads3` or use the `hint` watch subcommand for a\n// hint.\n\n\nuse std::sync::mpsc;\nuse std::sync::Arc;\nuse std::thread;\nuse std::time::Duration;\n\nstruct Queue {\n    length: u32,\n    first_half: Vec&lt;u32&gt;,\n    second_half: Vec&lt;u32&gt;,\n}\n\nimpl Queue {\n    fn new() -&gt; Self {\n        Queue {\n            length: 10,\n            first_half: vec![1, 2, 3, 4, 5],\n            second_half: vec![6, 7, 8, 9, 10],\n        }\n    }\n}\n\nfn send_tx(q: Queue, tx: mpsc::Sender&lt;u32&gt;) -&gt; () {\n    let qc = Arc::new(q);\n    let qc1 = Arc::clone(&amp;qc);\n    let qc2 = Arc::clone(&amp;qc);\n\n    let tx1 = tx.clone();\n    let tx2 = tx.clone();\n\n    thread::spawn(move || {\n        for val in &amp;qc1.first_half {\n            println!(\"sending {:?}\", val);\n            tx1.send(*val).unwrap();\n            thread::sleep(Duration::from_millis(5));\n        }\n    });\n\n    thread::spawn(move || {\n        for val in &amp;qc2.second_half {\n            println!(\"sending {:?}\", val);\n            tx2.send(*val).unwrap();\n            thread::sleep(Duration::from_millis(5));\n        }\n    });\n}\n\n#[test]\nfn main() {\n    let (tx, rx) = mpsc::channel();\n    let queue = Queue::new();\n    let queue_length = queue.length;\n\n    send_tx(queue, tx);\n\n    let mut total_received: u32 = 0;\n    for received in rx {\n        println!(\"Got: {}\", received);\n        total_received += 1;\n    }\n\n    println!(\"total numbers received: {}\", total_received);\n    assert_eq!(total_received, queue_length)\n}\n</code></pre></p>"},{"location":"rust/rustlings/21.macros/","title":"21.macros","text":""},{"location":"rust/rustlings/21.macros/#macros1rs","title":"macros1.rs","text":"<p>Github solution link <pre><code>// macros1.rs\n//\n// Execute `rustlings hint macros1` or use the `hint` watch subcommand for a\n// hint.\n\n\nmacro_rules! my_macro {\n    () =&gt; {\n        println!(\"Check out my macro!\");\n    };\n}\n\nfn main() {\n    my_macro!();\n}\n</code></pre></p>"},{"location":"rust/rustlings/21.macros/#macros2rs","title":"macros2.rs","text":"<p>Github solution link <pre><code>// macros2.rs\n//\n// Execute `rustlings hint macros2` or use the `hint` watch subcommand for a\n// hint.\n\n\nmacro_rules! my_macro {\n    () =&gt; {\n        println!(\"Check out my macro!\");\n    };\n}\n\nfn main() {\n    my_macro!();\n}\n</code></pre></p>"},{"location":"rust/rustlings/21.macros/#macros3rs","title":"macros3.rs","text":"<p>Github solution link <pre><code>// macros3.rs\n//\n// Make me compile, without taking the macro out of the module!\n//\n// Execute `rustlings hint macros3` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[macro_use]\nmod macros {\n    macro_rules! my_macro {\n        () =&gt; {\n            println!(\"Check out my macro!\");\n        };\n    }\n}\n\nfn main() {\n    my_macro!();\n}\n</code></pre></p>"},{"location":"rust/rustlings/21.macros/#macros4rs","title":"macros4.rs","text":"<p>Github solution link <pre><code>// macros4.rs\n//\n// Execute `rustlings hint macros4` or use the `hint` watch subcommand for a\n// hint.\n\n\n#[rustfmt::skip]\nmacro_rules! my_macro {\n    () =&gt; {\n        println!(\"Check out my macro!\");\n    };\n    ($val:expr) =&gt; {\n        println!(\"Look at this other macro: {}\", $val);\n    };\n}\n\nfn main() {\n    my_macro!();\n    my_macro!(7777);\n}\n</code></pre></p>"},{"location":"rust/rustlings/22.clippy/","title":"22.clippy","text":""},{"location":"rust/rustlings/22.clippy/#clippy1rs","title":"clippy1.rs","text":"<p>Github solution link <pre><code>// clippy1.rs\n//\n// The Clippy tool is a collection of lints to analyze your code so you can\n// catch common mistakes and improve your Rust code.\n//\n// For these exercises the code will fail to compile when there are clippy\n// warnings check clippy's suggestions from the output to solve the exercise.\n//\n// Execute `rustlings hint clippy1` or use the `hint` watch subcommand for a\n// hint.\n\n// I AM NOT DONE\n\nuse std::f32;\n\nfn main() {\n    // let pi = 3.14f32;\n    let pi = f32::consts::PI;\n    let radius = 5.00f32;\n\n    let area = pi * f32::powi(radius, 2);\n\n    println!(\n        \"The area of a circle with radius {:.2} is {:.5}!\",\n        radius, area\n    )\n}\n</code></pre></p>"},{"location":"rust/rustlings/22.clippy/#clippy2rs","title":"clippy2.rs","text":"<p>Github solution link <pre><code>// clippy2.rs\n// \n// Execute `rustlings hint clippy2` or use the `hint` watch subcommand for a\n// hint.\n\n// I AM NOT DONE\n\nfn main() {\n    let mut res = 42;\n    let option = Some(12);\n    if let Some(x) = option {\n        res += x;\n    }\n    println!(\"{}\", res);\n}\n</code></pre></p>"},{"location":"rust/rustlings/22.clippy/#clippy3rs","title":"clippy3.rs","text":"<p>Github solution link <pre><code>// clippy3.rs\n// \n// Here's a couple more easy Clippy fixes, so you can see its utility.\n// No hints.\n\n// I AM NOT DONE\n\n#[allow(unused_variables, unused_assignments)]\nfn main() {\n    let my_option: Option&lt;()&gt; = None;\n    if my_option.is_none() {\n        my_option.unwrap();\n    }\n\n    let my_arr = &amp;[\n        -1, -2, -3\n        -4, -5, -6\n    ];\n    println!(\"My array! Here it is: {:?}\", my_arr);\n\n    let my_empty_vec = vec![1, 2, 3, 4, 5].resize(0, 5);\n    println!(\"This Vec is empty, see? {:?}\", my_empty_vec);\n\n    let mut value_a = 45;\n    let mut value_b = 66;\n    // Let's swap these two!\n    value_a = value_b;\n    value_b = value_a;\n    println!(\"value a: {}; value b: {}\", value_a, value_b);\n}\n</code></pre></p>"},{"location":"rust/rustlings/23.conversions/","title":"23.conversions","text":""},{"location":"rust/rustlings/23.conversions/#as_ref_mutrs","title":"as_ref_mut.rs","text":"<p>Github solution link <pre><code>// as_ref_mut.rs\n//\n// AsRef and AsMut allow for cheap reference-to-reference conversions. Read more\n// about them at https://doc.rust-lang.org/std/convert/trait.AsRef.html and\n// https://doc.rust-lang.org/std/convert/trait.AsMut.html, respectively.\n//\n// Execute `rustlings hint as_ref_mut` or use the `hint` watch subcommand for a\n// hint.\n\n// I AM NOT DONE\n\n// Obtain the number of bytes (not characters) in the given argument.\n// TODO: Add the AsRef trait appropriately as a trait bound.\nfn byte_counter&lt;T: AsRef&lt;str&gt;&gt;(arg: T) -&gt; usize {\n    arg.as_ref().as_bytes().len()\n}\n\n// Obtain the number of characters (not bytes) in the given argument.\n// TODO: Add the AsRef trait appropriately as a trait bound.\nfn char_counter&lt;T: AsRef&lt;str&gt;&gt;(arg: T) -&gt; usize {\n    arg.as_ref().chars().count()\n}\n\n// Squares a number using as_mut().\n// TODO: Add the appropriate trait bound.\nfn num_sq&lt;T: AsMut&lt;u32&gt;&gt;(arg: &amp;mut T) {\n    // TODO: Implement the function body.\n    *arg.as_mut() = *arg.as_mut() * *arg.as_mut()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn different_counts() {\n        let s = \"Caf\u00e9 au lait\";\n        assert_ne!(char_counter(s), byte_counter(s));\n    }\n\n    #[test]\n    fn same_counts() {\n        let s = \"Cafe au lait\";\n        assert_eq!(char_counter(s), byte_counter(s));\n    }\n\n    #[test]\n    fn different_counts_using_string() {\n        let s = String::from(\"Caf\u00e9 au lait\");\n        assert_ne!(char_counter(s.clone()), byte_counter(s));\n    }\n\n    #[test]\n    fn same_counts_using_string() {\n        let s = String::from(\"Cafe au lait\");\n        assert_eq!(char_counter(s.clone()), byte_counter(s));\n    }\n\n    #[test]\n    fn mut_box() {\n        let mut num: Box&lt;u32&gt; = Box::new(3);\n        num_sq(&amp;mut num);\n        assert_eq!(*num, 9);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/23.conversions/#from_intors","title":"from_into.rs","text":"<p>Github solution link <pre><code>// from_into.rs\n//\n// The From trait is used for value-to-value conversions. If From is implemented\n// correctly for a type, the Into trait should work conversely. You can read\n// more about it at https://doc.rust-lang.org/std/convert/trait.From.html\n//\n// Execute `rustlings hint from_into` or use the `hint` watch subcommand for a\n// hint.\n\n#[derive(Debug)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We implement the Default trait to use it as a fallback\n// when the provided string is not convertible into a Person object\nimpl Default for Person {\n    fn default() -&gt; Person {\n        Person {\n            name: String::from(\"John\"),\n            age: 30,\n        }\n    }\n}\n\n// Your task is to complete this implementation in order for the line `let p =\n// Person::from(\"Mark,20\")` to compile Please note that you'll need to parse the\n// age component into a `usize` with something like `\"4\".parse::&lt;usize&gt;()`. The\n// outcome of this needs to be handled appropriately.\n//\n// Steps:\n// 1. If the length of the provided string is 0, then return the default of\n//    Person.\n// 2. Split the given string on the commas present in it.\n// 3. Extract the first element from the split operation and use it as the name.\n// 4. If the name is empty, then return the default of Person.\n// 5. Extract the other element from the split operation and parse it into a\n//    `usize` as the age.\n// If while parsing the age, something goes wrong, then return the default of\n// Person Otherwise, then return an instantiated Person object with the results\n\n// I AM NOT DONE\n\nimpl From&lt;&amp;str&gt; for Person {\n    fn from(s: &amp;str) -&gt; Person {\n        let parts: Vec&lt;&amp;str&gt; = s.split(',').collect();\n        if parts.len() &gt;= 2 &amp;&amp; parts[0].len() &gt; 0 {\n            let age: Result&lt;usize, _&gt; = parts[1].parse();\n            if let Ok(age) = age {\n                Person {\n                    name: parts[0].into(),\n                    age: age.into(),\n                }\n            } else {\n                Person::default()\n            }\n        } else {\n            Person::default()\n        }\n    }\n}\n\nfn main() {\n    // Use the `from` function\n    let p1 = Person::from(\"Mark,20\");\n    // Since From is implemented for Person, we should be able to use Into\n    let p2: Person = \"Gerald,70\".into();\n    println!(\"{:?}\", p1);\n    println!(\"{:?}\", p2);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn test_default() {\n        // Test that the default person is 30 year old John\n        let dp = Person::default();\n        assert_eq!(dp.name, \"John\");\n        assert_eq!(dp.age, 30);\n    }\n    #[test]\n    fn test_bad_convert() {\n        // Test that John is returned when bad string is provided\n        let p = Person::from(\"\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n    #[test]\n    fn test_good_convert() {\n        // Test that \"Mark,20\" works\n        let p = Person::from(\"Mark,20\");\n        assert_eq!(p.name, \"Mark\");\n        assert_eq!(p.age, 20);\n    }\n    #[test]\n    fn test_bad_age() {\n        // Test that \"Mark,twenty\" will return the default person due to an\n        // error in parsing age\n        let p = Person::from(\"Mark,twenty\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_comma_and_age() {\n        let p: Person = Person::from(\"Mark\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_age() {\n        let p: Person = Person::from(\"Mark,\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name() {\n        let p: Person = Person::from(\",1\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_age() {\n        let p: Person = Person::from(\",\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_missing_name_and_invalid_age() {\n        let p: Person = Person::from(\",one\");\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 30);\n    }\n\n    #[test]\n    fn test_trailing_comma() {\n        let p: Person = Person::from(\"Mike,32,\");\n        assert_eq!(p.name, \"Mike\");\n        assert_eq!(p.age, 32);\n    }\n\n    #[test]\n    fn test_trailing_comma_and_some_string() {\n        let p: Person = Person::from(\"Mike,32,man\");\n        assert_eq!(p.name, \"Mike\");\n        assert_eq!(p.age, 32);\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/23.conversions/#from_strrs","title":"from_str.rs","text":"<p>Github solution link <pre><code>// from_str.rs\n//\n// This is similar to from_into.rs, but this time we'll implement `FromStr` and\n// return errors instead of falling back to a default value. Additionally, upon\n// implementing FromStr, you can use the `parse` method on strings to generate\n// an object of the implementor type. You can read more about it at\n// https://doc.rust-lang.org/std/str/trait.FromStr.html\n//\n// Execute `rustlings hint from_str` or use the `hint` watch subcommand for a\n// hint.\n\nuse std::num::ParseIntError;\nuse std::str::FromStr;\n\n#[derive(Debug, PartialEq)]\nstruct Person {\n    name: String,\n    age: usize,\n}\n\n// We will use this error type for the `FromStr` implementation.\n#[derive(Debug, PartialEq)]\nenum ParsePersonError {\n    // Empty input string\n    Empty,\n    // Incorrect number of fields\n    BadLen,\n    // Empty name field\n    NoName,\n    // Wrapped error from parse::&lt;usize&gt;()\n    ParseInt(ParseIntError),\n}\n\n// I AM NOT DONE\n\n// Steps:\n// 1. If the length of the provided string is 0, an error should be returned\n// 2. Split the given string on the commas present in it\n// 3. Only 2 elements should be returned from the split, otherwise return an\n//    error\n// 4. Extract the first element from the split operation and use it as the name\n// 5. Extract the other element from the split operation and parse it into a\n//    `usize` as the age with something like `\"4\".parse::&lt;usize&gt;()`\n// 6. If while extracting the name and the age something goes wrong, an error\n//    should be returned\n// If everything goes well, then return a Result of a Person object\n//\n// As an aside: `Box&lt;dyn Error&gt;` implements `From&lt;&amp;'_ str&gt;`. This means that if\n// you want to return a string error message, you can do so via just using\n// return `Err(\"my error message\".into())`.\n\nimpl FromStr for Person {\n    type Err = ParsePersonError;\n    fn from_str(s: &amp;str) -&gt; Result&lt;Person, Self::Err&gt; {\n        if s.len() == 0 {\n            Err(ParsePersonError::Empty)\n        } else {\n            let parts: Vec&lt;&amp;str&gt; = s.split(',').collect();\n            // println!(\"{} {}\", s, parts.len());\n            if parts.len() == 2 {\n                let age: Result&lt;usize, _&gt; = parts[1].parse();\n                if parts[0].len() == 0 {\n                    Err(ParsePersonError::NoName)\n                } else {\n                    match age {\n                        Ok(age) =&gt; Ok(Person {\n                            name: parts[0].into(),\n                            age: age.into(),\n                        }),\n                        Err(e) =&gt; Err(ParsePersonError::ParseInt(e)),\n                    }\n                }\n            } else {\n                Err(ParsePersonError::BadLen)\n            }\n        }\n    }\n}\n\nfn main() {\n    let p = \"Mark,20\".parse::&lt;Person&gt;().unwrap();\n    println!(\"{:?}\", p);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn empty_input() {\n        assert_eq!(\"\".parse::&lt;Person&gt;(), Err(ParsePersonError::Empty));\n    }\n    #[test]\n    fn good_input() {\n        let p = \"John,32\".parse::&lt;Person&gt;();\n        assert!(p.is_ok());\n        let p = p.unwrap();\n        assert_eq!(p.name, \"John\");\n        assert_eq!(p.age, 32);\n    }\n    #[test]\n    fn missing_age() {\n        assert!(matches!(\n            \"John,\".parse::&lt;Person&gt;(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn invalid_age() {\n        assert!(matches!(\n            \"John,twenty\".parse::&lt;Person&gt;(),\n            Err(ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_comma_and_age() {\n        assert_eq!(\"John\".parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn missing_name() {\n        assert_eq!(\",1\".parse::&lt;Person&gt;(), Err(ParsePersonError::NoName));\n    }\n\n    #[test]\n    fn missing_name_and_age() {\n        assert!(matches!(\n            \",\".parse::&lt;Person&gt;(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn missing_name_and_invalid_age() {\n        assert!(matches!(\n            \",one\".parse::&lt;Person&gt;(),\n            Err(ParsePersonError::NoName | ParsePersonError::ParseInt(_))\n        ));\n    }\n\n    #[test]\n    fn trailing_comma() {\n        assert_eq!(\"John,32,\".parse::&lt;Person&gt;(), Err(ParsePersonError::BadLen));\n    }\n\n    #[test]\n    fn trailing_comma_and_some_string() {\n        assert_eq!(\n            \"John,32,man\".parse::&lt;Person&gt;(),\n            Err(ParsePersonError::BadLen)\n        );\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/23.conversions/#try_from_intors","title":"try_from_into.rs","text":"<p>Github solution link <pre><code>// try_from_into.rs\n//\n// TryFrom is a simple and safe type conversion that may fail in a controlled\n// way under some circumstances. Basically, this is the same as From. The main\n// difference is that this should return a Result type instead of the target\n// type itself. You can read more about it at\n// https://doc.rust-lang.org/std/convert/trait.TryFrom.html\n//\n// Execute `rustlings hint try_from_into` or use the `hint` watch subcommand for\n// a hint.\n\nuse std::convert::{TryFrom, TryInto};\n\n#[derive(Debug, PartialEq)]\nstruct Color {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n// We will use this error type for these `TryFrom` conversions.\n#[derive(Debug, PartialEq)]\nenum IntoColorError {\n    // Incorrect length of slice\n    BadLen,\n    // Integer conversion error\n    IntConversion,\n}\n\n// I AM NOT DONE\n\n// Your task is to complete this implementation and return an Ok result of inner\n// type Color. You need to create an implementation for a tuple of three\n// integers, an array of three integers, and a slice of integers.\n//\n// Note that the implementation for tuple and array will be checked at compile\n// time, but the slice implementation needs to check the slice length! Also note\n// that correct RGB color values must be integers in the 0..=255 range.\n\n// Tuple implementation\nimpl TryFrom&lt;(i16, i16, i16)&gt; for Color {\n    type Error = IntoColorError;\n    fn try_from(tuple: (i16, i16, i16)) -&gt; Result&lt;Self, Self::Error&gt; {\n        match (\n            u8::try_from(tuple.0),\n            u8::try_from(tuple.1),\n            u8::try_from(tuple.2),\n        ) {\n            (Ok(r), Ok(g), Ok(b)) =&gt; Ok(Color {\n                red: r,\n                green: g,\n                blue: b,\n            }),\n            _ =&gt; Err(IntoColorError::IntConversion),\n        }\n    }\n}\n\n// Array implementation\nimpl TryFrom&lt;[i16; 3]&gt; for Color {\n    type Error = IntoColorError;\n    fn try_from(arr: [i16; 3]) -&gt; Result&lt;Self, Self::Error&gt; {\n        match (\n            u8::try_from(arr[0]),\n            u8::try_from(arr[1]),\n            u8::try_from(arr[2]),\n        ) {\n            (Ok(r), Ok(g), Ok(b)) =&gt; Ok(Color {\n                red: r,\n                green: g,\n                blue: b,\n            }),\n            _ =&gt; Err(IntoColorError::IntConversion),\n        }\n    }\n}\n\n// Slice implementation\nimpl TryFrom&lt;&amp;[i16]&gt; for Color {\n    type Error = IntoColorError;\n    fn try_from(slice: &amp;[i16]) -&gt; Result&lt;Self, Self::Error&gt; {\n        if slice.len() != 3 {\n            Err(IntoColorError::BadLen)\n        } else {\n            match (\n                u8::try_from(slice[0]),\n                u8::try_from(slice[1]),\n                u8::try_from(slice[2]),\n            ) {\n                (Ok(r), Ok(g), Ok(b)) =&gt; Ok(Color {\n                    red: r,\n                    green: g,\n                    blue: b,\n                }),\n                _ =&gt; Err(IntoColorError::IntConversion),\n            }\n        }\n    }\n}\n\nfn main() {\n    // Use the `try_from` function\n    let c1 = Color::try_from((183, 65, 14));\n    println!(\"{:?}\", c1);\n\n    // Since TryFrom is implemented for Color, we should be able to use TryInto\n    let c2: Result&lt;Color, _&gt; = [183, 65, 14].try_into();\n    println!(\"{:?}\", c2);\n\n    let v = vec![183, 65, 14];\n    // With slice we should use `try_from` function\n    let c3 = Color::try_from(&amp;v[..]);\n    println!(\"{:?}\", c3);\n    // or take slice within round brackets and use TryInto\n    let c4: Result&lt;Color, _&gt; = (&amp;v[..]).try_into();\n    println!(\"{:?}\", c4);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_tuple_out_of_range_positive() {\n        assert_eq!(\n            Color::try_from((256, 1000, 10000)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_out_of_range_negative() {\n        assert_eq!(\n            Color::try_from((-1, -10, -256)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_sum() {\n        assert_eq!(\n            Color::try_from((-1, 255, 255)),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_tuple_correct() {\n        let c: Result&lt;Color, _&gt; = (183, 65, 14).try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_array_out_of_range_positive() {\n        let c: Result&lt;Color, _&gt; = [1000, 10000, 256].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_out_of_range_negative() {\n        let c: Result&lt;Color, _&gt; = [-10, -256, -1].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_sum() {\n        let c: Result&lt;Color, _&gt; = [-1, 255, 255].try_into();\n        assert_eq!(c, Err(IntoColorError::IntConversion));\n    }\n    #[test]\n    fn test_array_correct() {\n        let c: Result&lt;Color, _&gt; = [183, 65, 14].try_into();\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_positive() {\n        let arr = [10000, 256, 1000];\n        assert_eq!(\n            Color::try_from(&amp;arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_out_of_range_negative() {\n        let arr = [-256, -1, -10];\n        assert_eq!(\n            Color::try_from(&amp;arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_sum() {\n        let arr = [-1, 255, 255];\n        assert_eq!(\n            Color::try_from(&amp;arr[..]),\n            Err(IntoColorError::IntConversion)\n        );\n    }\n    #[test]\n    fn test_slice_correct() {\n        let v = vec![183, 65, 14];\n        let c: Result&lt;Color, _&gt; = Color::try_from(&amp;v[..]);\n        assert!(c.is_ok());\n        assert_eq!(\n            c.unwrap(),\n            Color {\n                red: 183,\n                green: 65,\n                blue: 14\n            }\n        );\n    }\n    #[test]\n    fn test_slice_excess_length() {\n        let v = vec![0, 0, 0, 0];\n        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));\n    }\n    #[test]\n    fn test_slice_insufficient_length() {\n        let v = vec![0, 0];\n        assert_eq!(Color::try_from(&amp;v[..]), Err(IntoColorError::BadLen));\n    }\n}\n</code></pre></p>"},{"location":"rust/rustlings/23.conversions/#using_asrs","title":"using_as.rs","text":"<p>Github solution link <pre><code>// using_as.rs\n//\n// Type casting in Rust is done via the usage of the `as` operator. Please note\n// that the `as` operator is not only used when type casting. It also helps with\n// renaming imports.\n//\n// The goal is to make sure that the division does not fail to compile and\n// returns the proper type.\n//\n// Execute `rustlings hint using_as` or use the `hint` watch subcommand for a\n// hint.\n\n// I AM NOT DONE\n\nfn average(values: &amp;[f64]) -&gt; f64 {\n    let total = values.iter().sum::&lt;f64&gt;();\n    total / values.len() as f64\n}\n\nfn main() {\n    let values = [3.5, 0.3, 13.0, 11.7];\n    println!(\"{}\", average(&amp;values));\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn returns_proper_type_and_value() {\n        assert_eq!(average(&amp;[3.5, 0.3, 13.0, 11.7]), 7.125);\n    }\n}\n</code></pre></p>"}]}